<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="favicon.svg" type="image/svg+xml">
    <title>Super Ninja Hyper Mega Ultra v51</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { 
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #1a1a2e; 
        }
        #gameCanvas {
            display: block;
            background: #0a0a14;
        }
        .game-container {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <canvas id="gameCanvas"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Dynamic viewport (fullscreen) and game area dimensions
        let VIEWPORT_WIDTH = window.innerWidth;
        let VIEWPORT_HEIGHT = window.innerHeight;
        const GAME_AREA_WIDTH = 2000;  // ~16:10 ratio
        const GAME_AREA_HEIGHT = 1250;
        const GAME_AREA_BORDER_COLOR = '#4ecca3';
        const OUTSIDE_AREA_COLOR = '#0a0a14';
        const GAME_AREA_COLOR = '#16213e';

        // Camera system with deadzone (Hotline Miami style)
        const camera = {
            x: GAME_AREA_WIDTH / 2,
            y: GAME_AREA_HEIGHT / 2,
            deadzone: 40,  // Player can move this much before camera follows
            smoothing: 0.08,  // How smoothly camera catches up (0-1, lower = smoother)
            zoom: 1.2,        // Current zoom level (starts at normalZoom)
            targetZoom: 1.2,  // Target zoom to animate towards (starts at normalZoom)
            zoomSmoothing: 0.06,  // How smoothly zoom transitions
            normalZoom: 1.2,     // Zoomed IN during normal time (bigger view)
            witchTimeZoom: 1.0  // Zoom OUT during witch time (see more)
        };

        // Keyboard state
        const keys = {};
        let keysJustPressed = {};
        let keysJustReleased = {};
        let keysPressedThisFrame = {};
        let keysReleasedThisFrame = {};
        
        window.addEventListener('keydown', e => {
            if (!keys[e.code]) keysPressedThisFrame[e.code] = true;
            keys[e.code] = true;
        });
        window.addEventListener('keyup', e => { 
            keys[e.code] = false; 
            keysReleasedThisFrame[e.code] = true;
        });
        
        function updateKeyboardState() {
            // Copy this frame's events to the readable state
            keysJustPressed = {...keysPressedThisFrame};
            keysJustReleased = {...keysReleasedThisFrame};
            // Clear for next frame
            keysPressedThisFrame = {};
            keysReleasedThisFrame = {};
        }

        function resizeCanvas() {
            // Dynamic viewport - fullscreen
            VIEWPORT_WIDTH = window.innerWidth;
            VIEWPORT_HEIGHT = window.innerHeight;
            canvas.width = VIEWPORT_WIDTH;
            canvas.height = VIEWPORT_HEIGHT;
        }
        window.addEventListener('resize', resizeCanvas);

        function updateCamera() {
            const player = game.player;

            // Calculate distance from camera center to player
            const dx = player.x - camera.x;
            const dy = player.y - camera.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            // Only move camera if player is outside deadzone
            if (dist > camera.deadzone) {
                // Move camera towards player, but only the amount outside deadzone
                const moveAmount = dist - camera.deadzone;
                const angle = Math.atan2(dy, dx);

                // Smooth camera movement
                camera.x += Math.cos(angle) * moveAmount * camera.smoothing;
                camera.y += Math.sin(angle) * moveAmount * camera.smoothing;
            }

            // Smooth zoom transition
            if (Math.abs(camera.zoom - camera.targetZoom) > 0.001) {
                camera.zoom += (camera.targetZoom - camera.zoom) * camera.zoomSmoothing;
            } else {
                camera.zoom = camera.targetZoom;
            }
        }

        // Convert world coordinates to screen coordinates (accounting for zoom)
        function worldToScreen(worldX, worldY) {
            const zoomedX = (worldX - camera.x) * camera.zoom + VIEWPORT_WIDTH / 2;
            const zoomedY = (worldY - camera.y) * camera.zoom + VIEWPORT_HEIGHT / 2;
            return { x: zoomedX, y: zoomedY };
        }

        // XP and Level system
        const xpSystem = {
            xp: 0,
            level: 1,
            xpToNext: 100,
            xpPerKill: { normal: 15, big: 50, boss: 150 }, // Big and boss give more XP
            levelUpFlash: 0,  // Flash timer for XP bar when leveling up
            hitFlash: 0       // Flash timer when gaining XP
        };

        // Power-up system - each powerup improves 2 stats
        const powerUps = {
            melee: 0,      // Melee damage + sword size (including charged)
            gun: 0,        // Gun damage + ROF
            dash: 0,       // Dash speed + distance
            witchTime: 0,  // Duration + enemy slowdown
            regen: 0       // HP regen rate + charge speed
        };

        // Track order of power-up acquisition (for left-to-right display)
        const powerUpOrder = [];

        // Power-up config - each improves 2 stats
        const powerUpConfig = {
            melee: { icon: 'ðŸ—¡ï¸', name: 'MEL', color: '#ff00ff' },     // Damage + sword size
            gun: { icon: 'ðŸ”«', name: 'GUN', color: '#ff4444' },       // Damage + ROF
            dash: { icon: 'ðŸ’¨', name: 'DSH', color: '#00ff88' },      // Speed + distance
            witchTime: { icon: 'â±ï¸', name: 'WTC', color: '#aa00ff' }, // Duration + slowdown
            regen: { icon: 'â¤ï¸', name: 'REG', color: '#ff6666' }      // Regen + charge speed
        };

        // Slot machine state - floating next to player
        const slotMachine = {
            active: false,
            spinning: true,
            currentIndex: 0,
            spinTimer: 0,
            maxSpinTime: 180, // 3 seconds at 60fps (auto-select)
            options: ['melee', 'gun', 'dash', 'witchTime', 'regen'],
            selectedOption: null,
            displayTimer: 0,
            shuffleTimer: 0
        };
        
        // Weapon system - ROF starts at 33% speed (3x higher delay), improves with levels
        const weapons = {
            smg: { name: 'SMG', baseFireRate: 360, fireRate: 360, bulletSpeed: 14, baseDamage: 0.2, damage: 0.2, spread: 0.15, autoAim: 0.35, color: '#44ddff', bulletsPerShot: 1 }, // 3x slower start
            // pistol: { name: 'PISTOL', baseFireRate: 1500, fireRate: 1500, bulletSpeed: 18, baseDamage: 0.8, damage: 0.8, spread: 0.05, autoAim: 0.4, color: '#ffff44', bulletsPerShot: 1 },
            shotgun: { name: 'SHOTGUN', baseFireRate: 1500, fireRate: 1500, bulletSpeed: 16, baseDamage: 0.4, damage: 0.4, spread: 0.3, autoAim: 0.25, color: '#ff8844', bulletsPerShot: 6 } // 3x slower start
        };
        const weaponOrder = ['smg', 'shotgun'];  // pistol disabled
        let currentWeaponIndex = 0;
        let weaponSwitchTimer = 0;  // Timer for auto weapon switch
        const WEAPON_AUTO_SWITCH_TIME = 600; // 10 seconds at 60fps
        const WEAPON_SWITCH_ENEMY_RANGE = 250; // Range to check for nearby enemies

        const game = {
            player: {
                x: GAME_AREA_WIDTH / 2, y: GAME_AREA_HEIGHT / 2,
                vx: 0, vy: 0,
                radius: 15,
                angle: 0,
                baseSpeed: 3.5, // Reduced starting speed (was 4.5)
                speed: 3.5,
                baseDashSpeed: 18,  // Nerfed 30% (was 25)
                dashSpeed: 18,
                baseDashDuration: 24,  // Nerfed 30% (was 34)
                dashDurationMax: 24,
                isDashing: false,
                dashCooldown: 0,
                dashDuration: 0,
                dashAngle: 0,
                dashMomentum: 0,
                postDashWindow: 0,
                collisionSlowdown: 0,
                autoAimTarget: null,
                autoAimLockTimer: 0,
                reticleAnim: 0,        // Lock-in animation progress (0 to 1)
                reticleRotation: 0,    // Current rotation angle for spinning markers
                color: '#4ecca3',
                meleeCooldown: 0,
                meleeFrame: 0,
                lastMeleeWasCharged: false, // Track if current melee is charged (for laser deflect)
                meleeComboCount: 0,         // Combo counter (0, 1, 2) - 3rd hit is special
                lastMeleeWasComboFinisher: false, // Track if current melee is combo finisher (for laser deflect)
                comboResetTimer: 0,         // Reset combo if no attack within this time
                dashMeleeUsed: false,
                isChargingMelee: false,
                meleeChargeTime: 0,
                meleeChargeMax: 42, // Faster charge (was 50)
                baseMeleeChargeMax: 42,
                chargeReady: false,
                movementPause: 0,
                isHurt: false,
                hurtTimer: 0,
                hurtSlowdown: 0.4,
                cantAttackTimer: 0,
                isParrying: false,
                parryTarget: null,
                parryProgress: 0,
                parryTargets: [],
                isKnockedBack: false,
                knockbackTimer: 0,
                isGrounded: false,
                groundedTimer: 0,
                parryIndicator: null,
                // Health system
                health: 100,           // Start with full HP
                maxHealth: 100,
                lastDamageTime: 0,     // Frame counter since last damage
                regenDelay: 90,        // 1.5 seconds before regen starts
                regenRate: 0.25,       // HP per frame (50% of original 0.5)
                baseRegenRate: 0.25
            },
            currentMoveAngle: 0,
            hasMoveInput: false,
            weapon: weapons.smg, // Reference to current weapon
            bullets: [],
            enemies: [],
            particles: [],
            dustParticles: [],
            ghostTrails: [],
            slashEffects: [],
            slashDeaths: [],
            chargeParticles: [],
            shockwaves: [],
            parrySequence: null,
            lastShot: 0,
            hitFreeze: 0,
            screenShake: 0,
            prevButtons: {},
            buttonsJustPressed: {},
            buttonsJustReleased: {},
            buttonsPressedThisFrame: {},
            buttonsReleasedThisFrame: {},
            maxEnemies: 30,
            bossSpawnTimer: 0,
            bossSpawnInterval: 1800,
            bossActive: false,
            slowMotion: 1,
            slowMotionTimer: 0,
            violetFilter: 0,
            parryCircle: null,
            parryFreeze: false,
            parryFreezeTimer: 0,
            laserDeflect: null, // Laser deflect visual
            laserThreat: null,  // Enemy currently targeting player with laser
            laserThreatTimer: 0,
            uiParticles: [], // Screen-space particles for UI effects (Perfect Clear, You Died, etc)
            powerUpFlash: {}, // Tracks blink timers for each power-up type
            paused: false, // Game paused state (H key)
            // Witch Time charge bar
            witchTimeCharge: {
                charge: 0,
                maxCharge: 100,
                chargePerHit: 5, // Charge gained per enemy hit (20 hits to fill)
                ready: false,
                canCharge: true, // Can only charge when witch time is not active
                justFilledFlash: 0, // Flash timer when bar just got filled
                hitFlash: 0 // Flash timer on each hit
            },
            // Witch Time (Bayonetta-style dodge)
            witchTime: {
                active: false,
                timer: 0,
                baseMaxTime: 360,     // 6 seconds at 60fps (+50% from 240)
                maxTime: 360,
                baseEnemySpeed: 0.20, // Enemy speed during witch time
                enemySpeed: 0.20,     // Upgradeable
                circleWipe: null, // For end animation
                killTimeBonus: 100, // Time restored per kill
                activationDash: false, // Flag for the initial dash that triggers witch time
                hitEnemies: [], // Track which enemies were hit during activation dash
                perfectClear: false, // Perfect clear state
                perfectClearTimer: 0, // Timer for perfect clear animation
                rechargeFlash: 0 // Flash when time is restored during witch time
            },
            // Death state - simplified with fades
            death: {
                active: false,
                phase: 0,           // 0=slomo+cut, 1=fadeToBlack, 2=youDied+waitRestart, 3=fadeOut, 4=fadeIn
                timer: 0,
                cutAngle: 0,
                cutPhase: 0,        // 0=first cut, 1=second cut (4 pieces total)
                fadeAlpha: 0,
                textShakeTimer: 0,
                canRestart: false,
                frozen: false,
                cameraOffset: 0     // Camera moves up during death
            }
        };

        // Melee attacks - slightly buffed base damage
        const meleeAttack = {
            arc: Math.PI * 0.9, duration: 8, baseDamage: 0.9, damage: 0.9,
            baseRange: 65, range: 65, color: '#ffffff', knockback: 10, cooldown: 12
        };

        const chargedMeleeAttack = {
            arc: Math.PI * 1.4, duration: 18, baseDamage: 2.0, damage: 2.0,
            baseRange: 110, range: 110, color: '#ff00ff', knockback: 25, cooldown: 30
        };

        const dashMeleeAttack = {
            baseWidth: 18, width: 18,
            baseLength: 160, length: 160,
            offset: 40,
            baseDamage: 1.5, damage: 1.5, duration: 15, color: '#ffaa00', knockback: 20
        };

        const chargedDashCone = { angle: Math.PI * 0.6, range: 240, damage: 4 };

        const enemyAttack = {
            chargeTime: 35, // Less than half of original 80 (fast attacks)
            blinkTime: 30, // 85% of chargeTime - yellow until here, then red
            blinkDuration: 6,
            parryWindow: 35, // Can parry anytime during charge
            damage: 1,
            range: 35,
            arc: Math.PI * 0.7,
            color: '#ff4444',
            attackPauseDuration: 30 // Half of original 60
        };

        const bossAttack = {
            chargeTime: 45, // Less than half of original 100
            blinkTime: 38, // 85% of chargeTime - yellow until here, then red
            blinkDuration: 8,
            parryWindow: 45, // Can parry anytime during charge
            damage: 2,
            range: 50,
            arc: Math.PI * 0.8,
            knockbackForce: 25,
            knockbackDuration: 40,
            groundedDuration: 50,
            attackPauseDuration: 40 // Half of original 80
        };

        // Laser attack system (for ENEMY_BIG and ENEMY_BOSS)
        const laserConfig = {
            getDetectionRange: () => VIEWPORT_HEIGHT * 0.5,  // 50% of viewport height (dynamic)
            // Big enemy laser
            big: {
                chargeTime: 68,      // 150% of 45 - longer targeting time
                aimDelay: 3,         // Less delay (was 4) - more responsive targeting
                fireDuration: 8,     // 70% of 12
                damage: 1,
                lineWidth: 2,        // Same as melee charge rings
                fireLineWidth: 0.17  // Thin laser beam (30% thinner)
            },
            // Boss laser
            boss: {
                chargeTime: 120,     // 150% of 80 - longer targeting time
                aimDelay: 4,         // Less delay (was 5) - more responsive targeting
                fireDuration: 18,    // 70% of 25
                damage: 2,
                lineWidth: 2,        // Same as melee charge rings
                fireLineWidth: 0.28  // Thin laser beam
            }
        };

        const ENEMY_NORMAL = 'normal';
        const ENEMY_BIG = 'big';
        const ENEMY_BOSS = 'boss';

        function spawnEnemyFromEdge(type = ENEMY_NORMAL) {
            const edge = Math.floor(Math.random() * 4);
            let x, y, vx, vy;
            
            const configs = {
                [ENEMY_NORMAL]: { baseSpeed: 0.7, size: 35, health: 2, color: '#e94560', aggroSpeed: 1.3, parryHealth: 1 },
                [ENEMY_BIG]: { baseSpeed: 0.45, size: 45, health: 5, color: '#5a6fd6', aggroSpeed: 1.0, parryHealth: 1 },
                [ENEMY_BOSS]: { baseSpeed: 0.3, size: 66, health: 12, color: '#d4aa00', aggroSpeed: 0.7, parryHealth: 3 }
            };
            
            const cfg = configs[type];
            const size = cfg.size;

            // Calculate visible area bounds (camera view)
            const viewHalfW = (VIEWPORT_WIDTH / 2) / camera.zoom;
            const viewHalfH = (VIEWPORT_HEIGHT / 2) / camera.zoom;
            const spawnMargin = 80; // Extra margin outside view

            // Always spawn OUTSIDE the camera view
            switch(edge) {
                case 0: // Top edge - above camera view
                    x = camera.x + (Math.random() - 0.5) * viewHalfW * 2;
                    y = camera.y - viewHalfH - spawnMargin - size;
                    vx = (Math.random() - 0.5) * cfg.baseSpeed;
                    vy = cfg.baseSpeed;
                    break;
                case 1: // Right edge - right of camera view
                    x = camera.x + viewHalfW + spawnMargin + size;
                    y = camera.y + (Math.random() - 0.5) * viewHalfH * 2;
                    vx = -cfg.baseSpeed;
                    vy = (Math.random() - 0.5) * cfg.baseSpeed;
                    break;
                case 2: // Bottom edge - below camera view
                    x = camera.x + (Math.random() - 0.5) * viewHalfW * 2;
                    y = camera.y + viewHalfH + spawnMargin + size;
                    vx = (Math.random() - 0.5) * cfg.baseSpeed;
                    vy = -cfg.baseSpeed;
                    break;
                case 3: // Left edge - left of camera view
                    x = camera.x - viewHalfW - spawnMargin - size;
                    y = camera.y + (Math.random() - 0.5) * viewHalfH * 2;
                    vx = cfg.baseSpeed;
                    vy = (Math.random() - 0.5) * cfg.baseSpeed;
                    break;
            }

            // Clamp to game area (but keep outside camera)
            x = Math.max(-size * 2, Math.min(GAME_AREA_WIDTH + size * 2, x));
            y = Math.max(-size * 2, Math.min(GAME_AREA_HEIGHT + size * 2, y));
            
            return {
                x, y, vx, vy,
                type: type,
                size: size,
                health: cfg.health,
                maxHealth: cfg.health,
                parryHealth: cfg.parryHealth,
                color: cfg.color,
                angle: Math.atan2(vy, vx),
                hit: 0,
                moveTimer: 60 + Math.random() * 120,
                baseSpeed: cfg.baseSpeed,
                aggroSpeed: cfg.aggroSpeed,
                aggroRange: type === ENEMY_BOSS ? 400 : 280,
                chargeRange: type === ENEMY_BOSS ? 300 : 220,
                orbitRange: type === ENEMY_BOSS ? 80 : (type === ENEMY_BIG ? 60 : 45),
                isAggro: false,
                respawnTimer: 0,
                dead: false,
                spawnFadeIn: 1.0,  // Fade-in animation (1.0 = starting, counts down to 0)
                spawnFadeDuration: 30, // 0.5 seconds at 60fps
                isCharging: false,
                chargeTime: 0,
                inParryWindow: false,
                hasBlinked: false,
                attackCooldown: 0,
                attackPause: 0,
                isStunned: false,
                stunTimer: 0,
                timeInAttackRange: 0, // New timer for attack delay
                // Boss laser properties
                laserCharging: false,
                laserChargeTime: 0,
                laserAimAngle: 0,      // Current aim angle (with delay)
                laserTargetAngle: 0,   // Target angle (instant to player)
                laserFiring: false,
                laserFireTimer: 0,
                laserRecoil: 0,        // Recoil force when firing
                laserRecoilAngle: 0,   // Direction of recoil
                // Visual bounce on hit
                hitBounce: 0,          // Current bounce animation (0-1)
                hitBounceType: 'melee' // 'melee' or 'gun' for different effects
            };
        }

        function initEnemies() {
            game.enemies = [];
            game.slashDeaths = [];
            game.bossActive = false;
            for (let i = 0; i < game.maxEnemies; i++) {
                game.enemies.push(spawnEnemyFromEdge(i < 2 ? ENEMY_BIG : ENEMY_NORMAL));
            }
            game.bossSpawnTimer = game.bossSpawnInterval;
        }

        function spawnBoss() {
            if (game.bossActive) return;
            game.enemies.push(spawnEnemyFromEdge(ENEMY_BOSS));
            game.bossActive = true;
        }

        // Check if enemy is visible on screen
        function isEnemyOnScreen(enemy) {
            const viewHalfW = (VIEWPORT_WIDTH / 2) / camera.zoom;
            const viewHalfH = (VIEWPORT_HEIGHT / 2) / camera.zoom;
            const dx = enemy.x - camera.x;
            const dy = enemy.y - camera.y;
            return Math.abs(dx) < viewHalfW + enemy.size && Math.abs(dy) < viewHalfH + enemy.size;
        }

        // Get laser config for enemy type
        function getLaserConfig(enemy) {
            return enemy.type === ENEMY_BOSS ? laserConfig.boss : laserConfig.big;
        }

        // Update laser system for ENEMY_BIG and ENEMY_BOSS
        function updateEnemyLaser(enemy, distToPlayer, angleToPlayer, enemyTime) {
            const player = game.player;
            const inWitchTime = game.witchTime.active && !game.witchTime.circleWipe;
            const config = getLaserConfig(enemy);

            // Don't do laser during witch time
            if (inWitchTime) {
                enemy.laserCharging = false;
                enemy.laserChargeTime = 0;
                enemy.laserFiring = false;
                return;
            }

            // Update firing state
            if (enemy.laserFiring) {
                enemy.laserFireTimer -= enemyTime;

                // Apply recoil movement (gradually decreases)
                if (enemy.laserRecoil > 0) {
                    const recoilMove = enemy.laserRecoil * 0.3;
                    const newX = enemy.x + Math.cos(enemy.laserRecoilAngle) * recoilMove;
                    const newY = enemy.y + Math.sin(enemy.laserRecoilAngle) * recoilMove;
                    // Keep within game bounds
                    enemy.x = Math.max(enemy.size, Math.min(GAME_AREA_WIDTH - enemy.size, newX));
                    enemy.y = Math.max(enemy.size, Math.min(GAME_AREA_HEIGHT - enemy.size, newY));
                    enemy.laserRecoil *= 0.85; // Decay
                    if (enemy.laserRecoil < 0.5) enemy.laserRecoil = 0;

                    // Spawn trail particles during recoil
                    if (Math.random() < 0.5) {
                        game.particles.push({
                            x: enemy.x - Math.cos(enemy.laserRecoilAngle) * enemy.size * 0.3,
                            y: enemy.y - Math.sin(enemy.laserRecoilAngle) * enemy.size * 0.3,
                            vx: (Math.random() - 0.5) * 2,
                            vy: (Math.random() - 0.5) * 2,
                            life: 15 + Math.random() * 10,
                            maxLife: 25,
                            radius: 2 + Math.random() * 2,
                            color: '#ffaa00'
                        });
                    }
                }

                if (enemy.laserFireTimer <= 0) {
                    enemy.laserFiring = false;
                    enemy.laserRecoil = 0;
                }
                return;
            }

            // Check if should start/continue targeting
            const onScreen = isEnemyOnScreen(enemy);
            const inRange = distToPlayer < laserConfig.getDetectionRange();

            if (enemy.laserCharging) {
                // Already charging - check if player left range
                if (!inRange) {
                    // Player escaped, cancel laser
                    enemy.laserCharging = false;
                    enemy.laserChargeTime = 0;
                    return;
                }

                // Update aim with delay (smooth follow)
                enemy.laserTargetAngle = angleToPlayer;
                const aimDiff = enemy.laserTargetAngle - enemy.laserAimAngle;
                let normalizedDiff = aimDiff;
                while (normalizedDiff > Math.PI) normalizedDiff -= Math.PI * 2;
                while (normalizedDiff < -Math.PI) normalizedDiff += Math.PI * 2;
                enemy.laserAimAngle += normalizedDiff * (1 / config.aimDelay) * enemyTime;

                // Increment charge
                enemy.laserChargeTime += enemyTime;

                // Check if player is in the laser aim path (for auto-aim to this enemy)
                checkLaserTargetingPlayer(enemy);

                // Deflect check - can deflect anytime during charge if player is doing CHARGED melee or COMBO FINISHER
                if (player.meleeFrame > 0 && player.meleeFrame < 12 && (player.lastMeleeWasCharged || player.lastMeleeWasComboFinisher)) {
                    const laserLength = 1500;
                    const laserEndX = enemy.x + Math.cos(enemy.laserAimAngle) * laserLength;
                    const laserEndY = enemy.y + Math.sin(enemy.laserAimAngle) * laserLength;
                    const playerDist = pointToLineDistance(player.x, player.y, enemy.x, enemy.y, laserEndX, laserEndY);
                    if (playerDist < 30 + player.radius) {
                        deflectLaser(enemy);
                        return;
                    }
                }

                // Fire when charged
                if (enemy.laserChargeTime >= config.chargeTime) {
                    fireEnemyLaser(enemy);
                }
            } else {
                // Not charging - check if should start
                if (onScreen && inRange && !enemy.isCharging && enemy.attackCooldown <= 0) {
                    // Start laser targeting
                    enemy.laserCharging = true;
                    enemy.laserChargeTime = 0;
                    enemy.laserAimAngle = angleToPlayer;
                    enemy.laserTargetAngle = angleToPlayer;
                }
            }
        }

        // Check if laser is targeting player (for auto-aim assist)
        function checkLaserTargetingPlayer(enemy) {
            const player = game.player;
            const laserLength = 1500;
            const laserEndX = enemy.x + Math.cos(enemy.laserAimAngle) * laserLength;
            const laserEndY = enemy.y + Math.sin(enemy.laserAimAngle) * laserLength;
            const playerDist = pointToLineDistance(player.x, player.y, enemy.x, enemy.y, laserEndX, laserEndY);

            // If laser is close to player, set this enemy as the laser threat
            if (playerDist < 50 + player.radius) {
                if (!game.laserThreat || game.laserThreatTimer <= 0) {
                    game.laserThreat = enemy;
                    game.laserThreatTimer = 10; // Small delay to avoid stutter
                }
            }
        }

        // Fire the laser
        function fireEnemyLaser(enemy) {
            const player = game.player;
            const config = getLaserConfig(enemy);

            enemy.laserCharging = false;
            enemy.laserChargeTime = 0;
            enemy.laserFiring = true;
            enemy.laserFireTimer = config.fireDuration;
            enemy.laserBlinkTimer = config.fireDuration; // For blink effect
            enemy.attackCooldown = enemy.type === ENEMY_BOSS ? 150 : 90;

            // Recoil - push enemy back opposite to laser direction
            const recoilForce = enemy.type === ENEMY_BOSS ? 20 : 12;
            enemy.laserRecoil = recoilForce; // Store for gradual movement
            enemy.laserRecoilAngle = enemy.laserAimAngle + Math.PI; // Opposite direction

            // Spawn particles from enemy (more particles for dramatic effect)
            const particleCount = enemy.type === ENEMY_BOSS ? 20 : 10;
            for (let i = 0; i < particleCount; i++) {
                // Particles spray out from both sides of laser origin
                const spreadAngle = enemy.laserAimAngle + (Math.random() - 0.5) * Math.PI;
                const speed = 4 + Math.random() * 6;
                game.particles.push({
                    x: enemy.x + Math.cos(enemy.laserAimAngle) * enemy.size * 0.5,
                    y: enemy.y + Math.sin(enemy.laserAimAngle) * enemy.size * 0.5,
                    vx: Math.cos(spreadAngle) * speed,
                    vy: Math.sin(spreadAngle) * speed,
                    life: 25 + Math.random() * 20,
                    maxLife: 45,
                    radius: enemy.type === ENEMY_BOSS ? 4 + Math.random() * 4 : 2 + Math.random() * 3,
                    color: Math.random() > 0.3 ? '#ffff00' : '#ffffff'
                });
            }

            // Check if player is hit by laser
            const laserLength = 1500;
            const laserWidth = enemy.type === ENEMY_BOSS ? 2 : 1.2; // 60% of previous (40% thinner)
            const laserEndX = enemy.x + Math.cos(enemy.laserAimAngle) * laserLength;
            const laserEndY = enemy.y + Math.sin(enemy.laserAimAngle) * laserLength;
            const playerDist = pointToLineDistance(player.x, player.y, enemy.x, enemy.y, laserEndX, laserEndY);

            if (playerDist < laserWidth + player.radius) {
                // Check if player is doing CHARGED melee or COMBO FINISHER (can deflect)
                if (player.meleeFrame > 0 && player.meleeFrame < 12 && (player.lastMeleeWasCharged || player.lastMeleeWasComboFinisher)) {
                    deflectLaser(enemy);
                } else if (!player.isDashing && !player.isHurt) {
                    // Player hit by laser
                    damagePlayer(enemy.x, enemy.y, enemy.type === ENEMY_BOSS, enemy.type === ENEMY_BIG, true);
                }
            }

            game.screenShake = enemy.type === ENEMY_BOSS ? 12 : 6;
        }

        // Deflect laser - enemy fires, player deflects it to another target
        function deflectLaser(enemy) {
            const player = game.player;
            const config = getLaserConfig(enemy);
            const isBoss = enemy.type === ENEMY_BOSS;

            // Cancel the enemy's laser completely (the deflect visual handles it)
            enemy.laserCharging = false;
            enemy.laserChargeTime = 0;
            enemy.laserFiring = false; // Don't show enemy laser, only deflect visual
            enemy.laserFireTimer = 0;
            enemy.attackCooldown = isBoss ? 150 : 90;

            // Find random visible enemy to redirect laser to
            let targetEnemy = null;
            const viewHalfW = (VIEWPORT_WIDTH / 2) / camera.zoom;
            const viewHalfH = (VIEWPORT_HEIGHT / 2) / camera.zoom;

            const visibleEnemies = game.enemies.filter(e => {
                if (e === enemy || e.dead || e.health <= 0) return false;
                const dx = e.x - camera.x;
                const dy = e.y - camera.y;
                return Math.abs(dx) < viewHalfW && Math.abs(dy) < viewHalfH;
            });

            if (visibleEnemies.length > 0) {
                targetEnemy = visibleEnemies[Math.floor(Math.random() * visibleEnemies.length)];
            }

            // Store deflect info for visual (with laser color based on enemy type)
            game.laserDeflect = {
                fromX: enemy.x,
                fromY: enemy.y,
                bounceX: player.x,
                bounceY: player.y,
                toX: targetEnemy ? targetEnemy.x : player.x + Math.cos(player.angle) * 200,
                toY: targetEnemy ? targetEnemy.y : player.y + Math.sin(player.angle) * 200,
                timer: 30,
                targetEnemy: targetEnemy,
                isBoss: isBoss, // For color/thickness
                lineWidth: isBoss ? config.fireLineWidth : config.fireLineWidth
            };

            // Brief time freeze (NOT witch time activation)
            game.hitFreeze = 12;

            // Damage the target enemy if exists - high damage to one-shot most enemies
            if (targetEnemy) {
                const deflectDamage = isBoss ? 15 : 8; // Enough to kill a big enemy (5 HP) in one hit
                targetEnemy.health -= deflectDamage;
                targetEnemy.hit = 15;
                spawnParticles(targetEnemy.x, targetEnemy.y, isBoss ? '#ffff00' : '#88aaff', 15, 8);
                if (targetEnemy.health <= 0) {
                    killEnemy(targetEnemy, player.x, player.y, false);
                }
            }

            // Visual feedback
            game.screenShake = isBoss ? 15 : 10;
            spawnShockwave(player.x, player.y, '#ffffff', 80);
            spawnParticles(player.x, player.y, isBoss ? '#ffff00' : '#88aaff', 15, 5);
        }

        // Helper: point to line distance
        function pointToLineDistance(px, py, x1, y1, x2, y2) {
            const A = px - x1;
            const B = py - y1;
            const C = x2 - x1;
            const D = y2 - y1;

            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            let param = -1;
            if (lenSq !== 0) param = dot / lenSq;

            let xx, yy;
            if (param < 0) {
                xx = x1;
                yy = y1;
            } else if (param > 1) {
                xx = x2;
                yy = y2;
            } else {
                xx = x1 + param * C;
                yy = y1 + param * D;
            }

            const dx = px - xx;
            const dy = py - yy;
            return Math.sqrt(dx * dx + dy * dy);
        }
        
        function updateAutoAim() {
            const player = game.player;

            // Update laser threat timer
            if (game.laserThreatTimer > 0) game.laserThreatTimer -= 1;
            if (game.laserThreatTimer <= 0) game.laserThreat = null;

            // Decrement lock timer
            if (player.autoAimLockTimer > 0) player.autoAimLockTimer -= 1;

            // Update reticle animation and rotation
            if (player.autoAimTarget && player.autoAimTarget.health > 0 && !player.autoAimTarget.dead) {
                player.reticleAnim = Math.min(1, player.reticleAnim + 0.12); // Lock-in over ~8 frames
                player.reticleRotation += 0.05; // Constant rotation speed
            } else {
                player.reticleAnim = 0;
            }

            // PRIORITY: If there's a laser threat, aim at it
            if (game.laserThreat && game.laserThreat.health > 0 && !game.laserThreat.dead && game.laserThreat.laserCharging) {
                const dx = game.laserThreat.x - player.x;
                const dy = game.laserThreat.y - player.y;
                player.angle = Math.atan2(dy, dx);
                player.autoAimTarget = game.laserThreat;
                return;
            }

            // Check if current target is still valid
            if (player.autoAimTarget) {
                const target = player.autoAimTarget;
                if (target.health <= 0 || target.dead) {
                    player.autoAimTarget = null;
                    player.autoAimLockTimer = 0;
                }
            }

            // If locked onto a target, keep it
            if (player.autoAimTarget && player.autoAimLockTimer > 0) {
                const dx = player.autoAimTarget.x - player.x;
                const dy = player.autoAimTarget.y - player.y;
                player.angle = Math.atan2(dy, dx);
                return;
            }

            // Find enemy at medium-long range for shooting (not closest, not farthest)
            // Find enemy at medium-long range for shooting - ONLY if visible on screen
            // Prioritize enemies between 200-600 pixels away
            let bestTarget = null;
            let bestScore = Infinity;
            game.enemies.forEach(enemy => {
                if (enemy.health <= 0 || enemy.dead) return;
                // Only target enemies visible on screen
                if (!isEnemyOnScreen(enemy)) return;

                const dx = enemy.x - player.x;
                const dy = enemy.y - player.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                // Scoring: prefer enemies at medium-long range (200-600px)
                // Closer than 200: less priority
                // 200-600: ideal range
                // Beyond 600: prefer closer ones
                let score;
                if (dist < 200) {
                    score = 200 - dist; // Lower priority for very close enemies
                } else if (dist <= 600) {
                    score = dist - 200; // Prefer further targets in this range
                } else {
                    score = 400 + (dist - 600); // Deprioritize very far enemies
                }

                if (score < bestScore) {
                    bestScore = score;
                    bestTarget = enemy;
                }
            });
            
            if (bestTarget) {
                // Lock onto new target
                if (bestTarget !== player.autoAimTarget) {
                    player.autoAimTarget = bestTarget;
                    player.autoAimLockTimer = 30; // Lock for 0.5 seconds
                    player.reticleAnim = 0; // Reset lock-in animation
                }
                const dx = bestTarget.x - player.x;
                const dy = bestTarget.y - player.y;
                player.angle = Math.atan2(dy, dx);
            }
        }

        function findNearestEnemy(fromX, fromY, aimAngle, maxAngle) {
            let nearest = null;
            let nearestScore = Infinity;
            game.enemies.forEach(enemy => {
                if (enemy.health <= 0 || enemy.dead) return;
                const dx = enemy.x - fromX;
                const dy = enemy.y - fromY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const angleToEnemy = Math.atan2(dy, dx);
                let angleDiff = angleToEnemy - aimAngle;
                while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                if (Math.abs(angleDiff) < maxAngle && dist < 400) {
                    const score = dist + Math.abs(angleDiff) * 200;
                    if (score < nearestScore) {
                        nearestScore = score;
                        nearest = { enemy, angleToEnemy, dist };
                    }
                }
            });
            return nearest;
        }

        function findParryTarget(dashAngle) {
            const player = game.player;
            let bestTarget = null;
            let bestDist = Infinity;
            game.enemies.forEach(enemy => {
                if (enemy.health <= 0 || enemy.dead || !enemy.inParryWindow) return;
                const dx = enemy.x - player.x;
                const dy = enemy.y - player.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const angleToEnemy = Math.atan2(dy, dx);
                // Only check distance, can dodge in any direction
                if (dist < 200 && dist < bestDist) {
                    bestDist = dist;
                    bestTarget = { enemy, angleToEnemy, dist };
                }
            });
            return bestTarget;
        }

        // Find enemy charging laser nearby (for witch time activation)
        function findLaserChargingEnemy() {
            const player = game.player;
            let bestTarget = null;
            let bestDist = Infinity;
            game.enemies.forEach(enemy => {
                if (enemy.health <= 0 || enemy.dead) return;
                // Only enemies charging laser (not yet firing)
                if (!enemy.laserCharging || enemy.laserFiring) return;
                const dx = enemy.x - player.x;
                const dy = enemy.y - player.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                // Generous range for laser parry (larger than melee parry)
                if (dist < 350 && dist < bestDist) {
                    bestDist = dist;
                    bestTarget = { enemy, dist };
                }
            });
            return bestTarget;
        }

        function findFirstParryableEnemy() {
            const player = game.player;
            let first = null;
            let minChargeRemaining = Infinity;
            game.enemies.forEach(enemy => {
                if (enemy.health <= 0 || enemy.dead || !enemy.isCharging) return;
                const dx = enemy.x - player.x;
                const dy = enemy.y - player.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < 200) {
                    const attackConfig = enemy.type === ENEMY_BOSS ? bossAttack : enemyAttack;
                    const remaining = attackConfig.chargeTime - enemy.chargeTime;
                    if (remaining < minChargeRemaining) {
                        minChargeRemaining = remaining;
                        first = enemy;
                    }
                }
            });
            return first;
        }

        function findNearbyEnemies(x, y, radius, exclude = []) {
            const nearby = [];
            game.enemies.forEach(enemy => {
                if (enemy.health <= 0 || enemy.dead) return;
                if (exclude.includes(enemy)) return;
                const dx = enemy.x - x;
                const dy = enemy.y - y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < radius) nearby.push(enemy);
            });
            return nearby;
        }

        function spawnParticles(x, y, color, count = 5, speed = 4) {
            // Limit total particles
            if (game.particles.length > 200) return;
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const spd = 2 + Math.random() * speed;
                game.particles.push({
                    x, y, vx: Math.cos(angle) * spd, vy: Math.sin(angle) * spd,
                    life: 30 + Math.random() * 20, maxLife: 50,
                    radius: 2 + Math.random() * 3, color
                });
            }
        }

        function spawnShockwave(x, y, color, maxRadius = 60) {
            game.shockwaves.push({ x, y, radius: 20, maxRadius, life: 15, maxLife: 15, color });
        }

        function spawnDust(x, y, moveAngle) {
            for (let i = 0; i < 8; i++) {
                const angle = moveAngle + Math.PI + (Math.random() - 0.5) * 1.2;
                const spd = 1 + Math.random() * 2;
                game.dustParticles.push({
                    x: x + (Math.random() - 0.5) * 10, y: y + (Math.random() - 0.5) * 10,
                    vx: Math.cos(angle) * spd, vy: Math.sin(angle) * spd,
                    life: 20 + Math.random() * 15, maxLife: 35, radius: 3 + Math.random() * 4
                });
            }
        }

        function addGhostTrail() {
            const player = game.player;
            game.ghostTrails.push({ x: player.x, y: player.y, angle: player.angle, radius: player.radius, life: 15, maxLife: 15 });
        }

        function createSlashEffect(attack, angle, x, y, trackPlayer = false, isCharged = false) {
            game.slashEffects.push({
                x, y, angle: angle + (attack.startAngle || 0),
                arc: attack.arc, range: attack.range,
                life: attack.duration, maxLife: attack.duration,
                color: attack.color, type: 'arc', trackPlayer, isCharged
            });
        }

        function createThrustEffect(x, y, angle, width, length, offset, duration, color) {
            game.slashEffects.push({
                x, y, angle, width, length, offset,
                life: duration, maxLife: duration, color, type: 'thrust', trackPlayer: false
            });
        }

        function createPiece(x, y, size, color, type, angle, side) {
            return { x, y, size, color, type, cutAngle: angle, side };
        }

        function startParrySequence(mainEnemy, nearbyEnemies, playerAngle) {
            const player = game.player;
            const mainDies = mainEnemy.parryHealth <= 1;
            if (!mainDies) {
                mainEnemy.parryHealth--;
                mainEnemy.health -= 3;
                mainEnemy.isStunned = true;
                mainEnemy.stunTimer = 90;
                mainEnemy.isCharging = false;
                mainEnemy.chargeTime = 0;
                mainEnemy.inParryWindow = false;
                mainEnemy.hasBlinked = false;
            }
            
            const cutAngle = playerAngle;
            
            game.parrySequence = {
                phase: 0,
                timer: 0,
                mainEnemy: {
                    x: mainEnemy.x, y: mainEnemy.y,
                    size: mainEnemy.size, color: mainEnemy.color, type: mainEnemy.type,
                    dies: mainDies, cutAngle: cutAngle, pieces: null, enemy: mainEnemy,
                    blinkTimer: mainDies ? 20 : 0
                },
                nearbyEnemies: nearbyEnemies.map(e => ({
                    x: e.x, y: e.y, size: e.size, color: e.color, type: e.type,
                    cutAngle: Math.atan2(e.y - player.y, e.x - player.x),
                    pieces: null, enemy: e,
                    blinkTimer: 20
                })),
                slashLines: []
            };
            
            // Award XP for kills
            if (mainDies) {
                mainEnemy.dead = true;
                // Longer respawn times, bosses take even longer
                if (mainEnemy.type === ENEMY_BOSS) {
                    mainEnemy.respawnTimer = 400 + Math.random() * 200;
                    game.bossActive = false;
                } else {
                    mainEnemy.respawnTimer = 200 + Math.random() * 150;
                }
                if (mainEnemy.type === ENEMY_BOSS && !mainEnemy.respawnTimer) game.bossActive = false;
                addXP(mainEnemy.type);
            }
            nearbyEnemies.forEach(e => {
                e.dead = true;
                // Longer respawn times, bosses take even longer
                if (e.type === ENEMY_BOSS) {
                    e.respawnTimer = 400 + Math.random() * 200;
                    game.bossActive = false;
                } else {
                    e.respawnTimer = 200 + Math.random() * 150;
                }
                if (e.type === ENEMY_BOSS && !e.respawnTimer) game.bossActive = false;
                addXP(e.type);
            });
        }

        function updateParrySequence(timeScale) {
            const seq = game.parrySequence;
            if (!seq) return;
            
            seq.timer += timeScale;
            const phaseDuration = 25;
            
            // Update blink timers
            if (seq.mainEnemy.blinkTimer > 0) seq.mainEnemy.blinkTimer -= timeScale;
            seq.nearbyEnemies.forEach(e => { if (e.blinkTimer > 0) e.blinkTimer -= timeScale; });
            
            if (seq.phase === 0 && seq.timer >= 5) {
                seq.phase = 1;
                seq.timer = 0;
                const m = seq.mainEnemy;
                if (m.dies) {
                    m.pieces = [
                        createPiece(m.x, m.y, m.size, m.color, m.type, m.cutAngle, 1),
                        createPiece(m.x, m.y, m.size, m.color, m.type, m.cutAngle, -1)
                    ];
                    seq.slashLines.push({ x: m.x, y: m.y, angle: m.cutAngle, life: 30, maxLife: 30, length: m.size * 1.5 });
                } else {
                    seq.slashLines.push({ x: m.x, y: m.y, angle: m.cutAngle, life: 30, maxLife: 30, length: m.size * 1.2 });
                    seq.slashLines.push({ x: m.x + (Math.random()-0.5)*m.size*0.5, y: m.y + (Math.random()-0.5)*m.size*0.5, angle: Math.random() * Math.PI, life: 30, maxLife: 30, length: m.size * 0.8 });
                    seq.slashLines.push({ x: m.x + (Math.random()-0.5)*m.size*0.5, y: m.y + (Math.random()-0.5)*m.size*0.5, angle: Math.random() * Math.PI, life: 30, maxLife: 30, length: m.size * 0.8 });
                }
                spawnParticles(m.x, m.y, '#ffffff', 15, 8);
                game.screenShake = 8;
            }
            
            if (seq.phase === 1 && seq.timer >= phaseDuration) {
                seq.phase = 2;
                seq.timer = 0;
                const m = seq.mainEnemy;
                if (m.dies && m.pieces) {
                    const perpAngle = m.cutAngle + Math.PI / 2;
                    m.pieces[0].x += Math.cos(perpAngle) * 8;
                    m.pieces[0].y += Math.sin(perpAngle) * 8;
                    m.pieces[1].x -= Math.cos(perpAngle) * 8;
                    m.pieces[1].y -= Math.sin(perpAngle) * 8;
                    const newPieces = [];
                    m.pieces.forEach(p => {
                        const newCutAngle = m.cutAngle + Math.PI / 2;
                        newPieces.push(createPiece(p.x, p.y, p.size * 0.6, p.color, p.type, newCutAngle, 1));
                        newPieces.push(createPiece(p.x, p.y, p.size * 0.6, p.color, p.type, newCutAngle, -1));
                        seq.slashLines.push({ x: p.x, y: p.y, angle: newCutAngle, life: 30, maxLife: 30, length: p.size * 0.8 });
                    });
                    m.pieces = newPieces;
                }
                seq.nearbyEnemies.forEach(e => {
                    e.pieces = [
                        createPiece(e.x, e.y, e.size, e.color, e.type, e.cutAngle, 1),
                        createPiece(e.x, e.y, e.size, e.color, e.type, e.cutAngle, -1)
                    ];
                    seq.slashLines.push({ x: e.x, y: e.y, angle: e.cutAngle, life: 30, maxLife: 30, length: e.size * 1.5 });
                    spawnParticles(e.x, e.y, '#ffffff', 10, 6);
                });
                game.screenShake = 10;
            }
            
            if (seq.phase === 2 && seq.timer >= phaseDuration) {
                seq.phase = 3;
                seq.timer = 0;
                seq.nearbyEnemies.forEach(e => {
                    if (e.pieces) {
                        const newPieces = [];
                        e.pieces.forEach(p => {
                            const perpAngle = e.cutAngle + Math.PI / 2;
                            p.x += Math.cos(perpAngle) * p.side * 6;
                            p.y += Math.sin(perpAngle) * p.side * 6;
                            const newCutAngle = e.cutAngle + Math.PI / 2;
                            newPieces.push(createPiece(p.x, p.y, p.size * 0.6, p.color, p.type, newCutAngle, 1));
                            newPieces.push(createPiece(p.x, p.y, p.size * 0.6, p.color, p.type, newCutAngle, -1));
                            seq.slashLines.push({ x: p.x, y: p.y, angle: newCutAngle, life: 30, maxLife: 30, length: p.size * 0.8 });
                        });
                        e.pieces = newPieces;
                    }
                });
                game.screenShake = 8;
            }
            
            if (seq.phase === 3 && seq.timer >= phaseDuration) {
                seq.phase = 4;
                seq.timer = 0;
                const m = seq.mainEnemy;
                if (m.dies && m.pieces) {
                    m.pieces.forEach(p => {
                        spawnParticles(p.x, p.y, p.color, 8, 6);
                        spawnParticles(p.x, p.y, '#ff0000', 5, 4);
                    });
                }
                seq.nearbyEnemies.forEach(e => {
                    if (e.pieces) {
                        e.pieces.forEach(p => {
                            spawnParticles(p.x, p.y, p.color, 6, 5);
                            spawnParticles(p.x, p.y, '#ff0000', 4, 3);
                        });
                    }
                });
                game.screenShake = 12;
            }
            
            if (seq.phase === 4 && seq.timer >= 30) {
                game.parrySequence = null;
            }
            
            seq.slashLines = seq.slashLines.filter(s => { s.life -= timeScale; return s.life > 0; });
            
            if (seq.mainEnemy.pieces) {
                seq.mainEnemy.pieces.forEach(p => {
                    const perpAngle = p.cutAngle + Math.PI / 2;
                    p.x += Math.cos(perpAngle) * p.side * 0.5 * timeScale;
                    p.y += Math.sin(perpAngle) * p.side * 0.5 * timeScale;
                });
            }
            seq.nearbyEnemies.forEach(e => {
                if (e.pieces) {
                    e.pieces.forEach(p => {
                        const perpAngle = p.cutAngle + Math.PI / 2;
                        p.x += Math.cos(perpAngle) * p.side * 0.5 * timeScale;
                        p.y += Math.sin(perpAngle) * p.side * 0.5 * timeScale;
                    });
                }
            });
        }

        function killEnemy(enemy, playerX, playerY, useSlashEffect = true) {
            enemy.dead = true;
            // Longer respawn times, bosses take even longer
            if (enemy.type === ENEMY_BOSS) {
                enemy.respawnTimer = 400 + Math.random() * 200;
                game.bossActive = false;
            } else {
                enemy.respawnTimer = 200 + Math.random() * 150;
            }
            addXP(enemy.type);

            // Restore witch time duration on kill
            if (game.witchTime.active && !game.witchTime.circleWipe) {
                game.witchTime.timer = Math.min(game.witchTime.maxTime, game.witchTime.timer + game.witchTime.killTimeBonus);
                game.witchTime.rechargeFlash = 20; // Flash the bar
            }
            if (useSlashEffect && game.slashDeaths.length < 15) {
                // Radial slash lines pointing towards player (from enemy to player)
                const slashAngle = Math.atan2(playerY - enemy.y, playerX - enemy.x);
                game.slashDeaths.push({
                    x: enemy.x, y: enemy.y, size: enemy.size, color: enemy.color, type: enemy.type,
                    slashAngle, phase: 'flash', timer: 0, separation: 0
                });
            } else {
                spawnParticles(enemy.x, enemy.y, '#ff0000', 8);
            }
        }

        // XP and Level functions
        function addXP(enemyType) {
            const xpGain = xpSystem.xpPerKill[enemyType] || 10;
            xpSystem.xp += xpGain;
            // Flash on XP gain
            xpSystem.hitFlash = 15;

            if (xpSystem.xp >= xpSystem.xpToNext) {
                levelUp();
            }
        }

        function levelUp() {
            xpSystem.level++;
            xpSystem.xp = Math.max(0, xpSystem.xp - xpSystem.xpToNext);
            xpSystem.xpToNext = Math.floor(xpSystem.xpToNext * 1.5);
            xpSystem.levelUpFlash = 120; // Flash for 2 seconds furiously

            // Start slot machine
            startSlotMachine();
        }

        function startSlotMachine() {
            slotMachine.active = true;
            slotMachine.spinning = true;
            slotMachine.spinTimer = 0;
            slotMachine.shuffleTimer = 0;
            slotMachine.currentIndex = Math.floor(Math.random() * slotMachine.options.length);
            slotMachine.selectedOption = null;
            slotMachine.displayTimer = 0;
            // No slowmo - game continues normally
        }

        function stopSlotMachine() {
            slotMachine.spinning = false;
            slotMachine.selectedOption = slotMachine.options[slotMachine.currentIndex];
            applyPowerUp(slotMachine.selectedOption);
            slotMachine.displayTimer = 150; // ~2.5 seconds display
        }

        function endSlotMachine() {
            slotMachine.active = false;
            slotMachine.selectedOption = null;
        }

        function applyPowerUp(type) {
            // Track order of first acquisition
            if (powerUps[type] === 0) {
                powerUpOrder.push(type);
            }

            powerUps[type]++;

            // Trigger particle explosion for this power-up (will be spawned in render)
            if (!game.powerUpFlash) game.powerUpFlash = {};
            game.powerUpFlash[type] = 30; // Short blink
            game.powerUpParticles = game.powerUpParticles || {};
            game.powerUpParticles[type] = true; // Mark to spawn particles on next render

            // Recalculate all stats based on new powerup system
            // Each powerup improves 2 stats

            // MELEE: Damage + Sword Size (range)
            const meleeBonus = powerUps.melee;
            meleeAttack.damage = meleeAttack.baseDamage + (meleeBonus * 0.4);
            meleeAttack.range = meleeAttack.baseRange + (meleeBonus * 8);
            chargedMeleeAttack.damage = chargedMeleeAttack.baseDamage + (meleeBonus * 0.8);
            chargedMeleeAttack.range = chargedMeleeAttack.baseRange + (meleeBonus * 15);

            // GUN: Damage + ROF
            const gunBonus = powerUps.gun;
            Object.keys(weapons).forEach(wKey => {
                const w = weapons[wKey];
                w.damage = w.baseDamage + (gunBonus * 0.15);
                w.fireRate = Math.max(50, w.baseFireRate - (gunBonus * 70));
            });

            // DASH: Speed + Distance (duration)
            const dashBonus = powerUps.dash;
            game.player.dashSpeed = game.player.baseDashSpeed + (dashBonus * 4);
            game.player.dashDurationMax = game.player.baseDashDuration + (dashBonus * 5);

            // WITCH TIME: Duration (main) + Enemy Slowdown (subtle)
            const wtBonus = powerUps.witchTime;
            // Duration increases significantly with each level
            game.witchTime.maxTime = game.witchTime.baseMaxTime + (wtBonus * 50);
            // Slowdown gets slightly more intense (smaller improvement)
            game.witchTime.enemySpeed = Math.max(0.05, game.witchTime.baseEnemySpeed - (wtBonus * 0.01));

            // REGEN: HP Regen + Charge Speed
            const regenBonus = powerUps.regen;
            game.player.regenRate = game.player.baseRegenRate + (regenBonus * 0.2);
            game.player.meleeChargeMax = Math.max(25, game.player.baseMeleeChargeMax - (regenBonus * 6));
        }
        
        function cycleWeapon() {
            currentWeaponIndex = (currentWeaponIndex + 1) % weaponOrder.length;
            game.weapon = weapons[weaponOrder[currentWeaponIndex]];
        }

        function updateSlotMachine(timeScale) {
            if (!slotMachine.active) return;
            
            if (slotMachine.spinning) {
                slotMachine.spinTimer += timeScale;
                slotMachine.shuffleTimer += timeScale;
                
                // Calculate shuffle interval - starts fast (2 frames), slows to 12 frames
                const progress = slotMachine.spinTimer / slotMachine.maxSpinTime;
                const easeProgress = progress * progress; // Quadratic ease-out for deceleration
                const minInterval = 4;
                const maxInterval = 18;
                const currentInterval = minInterval + (maxInterval - minInterval) * easeProgress;
                
                // Shuffle to next icon
                if (slotMachine.shuffleTimer >= currentInterval) {
                    slotMachine.shuffleTimer = 0;
                    slotMachine.currentIndex = (slotMachine.currentIndex + 1) % slotMachine.options.length;
                }
                
                // Auto-stop after 3 seconds
                if (slotMachine.spinTimer >= slotMachine.maxSpinTime) {
                    stopSlotMachine();
                }
            } else if (slotMachine.displayTimer > 0) {
                slotMachine.displayTimer -= timeScale;
                if (slotMachine.displayTimer <= 0) {
                    endSlotMachine();
                }
            }
        }

        function stunEnemy(enemy) {
            enemy.isStunned = true;
            enemy.stunTimer = 30;
            enemy.isCharging = false;
            enemy.chargeTime = 0;
            enemy.inParryWindow = false;
            enemy.hasBlinked = false;
        }

        function damagePlayer(fromX, fromY, isBossAttack = false, isBigAttack = false, isLaser = false) {
            const player = game.player;
            if (player.isParrying) return;

            // Calculate damage based on attack type
            let damage = 10; // Normal enemy melee
            if (isLaser) {
                damage = isBossAttack ? 25 : 15; // Boss laser = 25, Big enemy laser = 15
            } else if (isBossAttack) {
                damage = 30; // Boss melee
            } else if (isBigAttack) {
                damage = 20; // Big enemy melee
            }

            // Apply damage
            player.health -= damage;
            player.lastDamageTime = 0; // Reset regen timer

            player.isHurt = true;
            player.hurtTimer = 45;
            player.cantAttackTimer = 20;
            const angle = Math.atan2(player.y - fromY, player.x - fromX);
            if (isBossAttack && !isLaser) {
                player.isKnockedBack = true;
                player.knockbackTimer = bossAttack.knockbackDuration;
                player.vx = Math.cos(angle) * bossAttack.knockbackForce;
                player.vy = Math.sin(angle) * bossAttack.knockbackForce;
                game.screenShake = 15;
                // Boss shockwave effect
                spawnShockwave(fromX, fromY, '#ffaa00', 80);
                spawnParticles(fromX, fromY, '#ffaa00', 20, 8);
            } else if (isBigAttack && !isLaser) {
                player.isKnockedBack = true;
                player.knockbackTimer = 25; // Shorter than boss
                player.vx = Math.cos(angle) * 15; // Less force than boss
                player.vy = Math.sin(angle) * 15;
                game.screenShake = 12;
                // Big enemy shockwave effect
                spawnShockwave(fromX, fromY, '#5a6fd6', 60);
                spawnParticles(fromX, fromY, '#5a6fd6', 15, 6);
            } else if (isLaser) {
                // Laser knockback (lighter)
                player.vx = Math.cos(angle) * 5;
                player.vy = Math.sin(angle) * 5;
                game.screenShake = isBossAttack ? 12 : 8;
            } else {
                player.vx = Math.cos(angle) * 8;
                player.vy = Math.sin(angle) * 8;
                game.screenShake = 10;
            }
            spawnParticles(player.x, player.y, '#ff0000', 15, 6);

            // Check for death
            if (player.health <= 0) {
                player.health = 0;
                startPlayerDeath();
            }
        }

        function addWitchTimeCharge() {
            // Only charge when not in witch time and can charge
            if (game.witchTimeCharge.canCharge && !game.witchTime.active) {
                const wasReady = game.witchTimeCharge.ready;
                game.witchTimeCharge.charge += game.witchTimeCharge.chargePerHit;
                // Flash every time charge is added (same as when full)
                game.witchTimeCharge.hitFlash = 20;
                if (game.witchTimeCharge.charge >= game.witchTimeCharge.maxCharge) {
                    game.witchTimeCharge.charge = game.witchTimeCharge.maxCharge;
                    game.witchTimeCharge.ready = true;
                    // Start longer flash when just filled
                    if (!wasReady) {
                        game.witchTimeCharge.justFilledFlash = 120; // 2 seconds of flash
                    }
                }
            }
        }

        // Player death system - simplified
        function startPlayerDeath() {
            const death = game.death;
            death.active = true;
            death.phase = 0;
            death.timer = 0;
            death.fadeAlpha = 1; // Instant black
            death.textShakeTimer = 60;
            death.canRestart = false;
            death.frozen = true;

            // Reset slow motion
            game.slowMotion = 1;
            game.screenShake = 0;
        }

        function updatePlayerDeath() {
            const death = game.death;
            if (!death.active) return false;

            death.timer++;

            switch (death.phase) {
                case 0: // Instant black screen with YOU DIED
                    // Immediately show black screen
                    death.fadeAlpha = 1;
                    if (death.textShakeTimer > 0) death.textShakeTimer--;
                    if (death.timer >= 60) {
                        death.canRestart = true;
                    }
                    break;

                case 1: // After pressing restart - reset and fade in
                    if (death.timer === 1) {
                        resetGame();
                        camera.targetZoom = camera.normalZoom;
                    }
                    death.fadeAlpha = Math.max(0, 1 - death.timer / 30);
                    if (death.timer >= 30) {
                        death.active = false;
                        death.frozen = false;
                        game.slowMotion = 1;
                    }
                    break;
            }

            return true;
        }

        function resetGame() {
            const player = game.player;
            // Reset player
            player.x = GAME_AREA_WIDTH / 2;
            player.y = GAME_AREA_HEIGHT / 2;
            player.vx = 0;
            player.vy = 0;
            player.health = 50; // Start with half HP
            player.lastDamageTime = 0;
            player.isHurt = false;
            player.hurtTimer = 0;
            player.isDashing = false;
            player.dashCooldown = 0;
            player.isKnockedBack = false;
            player.isGrounded = false;
            player.meleeFrame = 0;
            player.isChargingMelee = false;
            player.meleeChargeTime = 0;
            player.chargeReady = false;

            // Reset witch time
            game.witchTime.active = false;
            game.witchTime.circleWipe = null;
            game.witchTime.perfectClear = false;
            game.witchTimeCharge.charge = 0;
            game.witchTimeCharge.ready = false;
            game.witchTimeCharge.canCharge = true;
            game.witchTimeCharge.justFilledFlash = 0;

            // Reset XP and level
            xpSystem.xp = 0;
            xpSystem.level = 1;
            xpSystem.xpToNext = 100;

            // Reset power-ups
            Object.keys(powerUps).forEach(k => powerUps[k] = 0);
            powerUpOrder.length = 0;

            // Reset stats to base
            player.speed = player.baseSpeed;
            player.regenRate = player.baseRegenRate;
            player.meleeChargeMax = player.baseMeleeChargeMax;
            player.dashSpeed = player.baseDashSpeed;
            player.dashDurationMax = player.baseDashDuration;
            meleeAttack.damage = meleeAttack.baseDamage;
            chargedMeleeAttack.damage = chargedMeleeAttack.baseDamage;
            dashMeleeAttack.damage = dashMeleeAttack.baseDamage;
            dashMeleeAttack.width = dashMeleeAttack.baseWidth;
            dashMeleeAttack.length = dashMeleeAttack.baseLength;
            Object.keys(weapons).forEach(wKey => {
                const w = weapons[wKey];
                w.damage = w.baseDamage;
                w.fireRate = w.baseFireRate;
            });

            // Reset slot machine
            slotMachine.active = false;

            // Reset weapon
            currentWeaponIndex = 0;
            game.weapon = weapons[weaponOrder[0]];
            weaponSwitchTimer = 0;

            // Reset enemies
            initEnemies();

            // Clear particles and effects
            game.particles = [];
            game.dustParticles = [];
            game.shockwaves = [];
            game.slashEffects = [];
            game.uiParticles = [];
            game.bullets = [];
            game.ghostTrails = [];
            game.powerUpFlash = {};
            xpSystem.levelUpFlash = 0;

            // Reset camera
            camera.x = player.x;
            camera.y = player.y;
            camera.targetZoom = camera.normalZoom;
            camera.zoom = camera.normalZoom;

            game.slowMotion = 1;
            game.violetFilter = 0;

            // Death state is reset by updatePlayerDeath when phase 4 completes
            // But set active = false here for safety
            game.death.active = false;
            game.death.frozen = false;
        }

        function checkRestartInput(gamepad) {
            // Check keyboard
            if (Object.values(keysJustPressed).some(v => v)) {
                return true;
            }
            // Check gamepad
            if (gamepad) {
                for (let i = 0; i < gamepad.buttons.length; i++) {
                    if (buttonJustPressed(gamepad.buttons, i)) {
                        return true;
                    }
                }
            }
            return false;
        }

        function checkThrustHit(enemy, playerX, playerY, attackAngle, attackLength, attackWidth, attackOffset, damage, knockback) {
            const dx = enemy.x - playerX;
            const dy = enemy.y - playerY;
            const cos = Math.cos(-attackAngle);
            const sin = Math.sin(-attackAngle);
            const localX = dx * cos - dy * sin;
            const localY = dx * sin + dy * cos;
            const hitRadius = enemy.size / 2;
            if (localX > attackOffset && localX < attackOffset + attackLength + hitRadius &&
                Math.abs(localY) < attackWidth / 2 + hitRadius) {
                // x2 damage during witch time
                const inWitchTime = game.witchTime.active && !game.witchTime.circleWipe;
                const finalDamage = inWitchTime ? damage * 2 : damage;
                enemy.health -= finalDamage;
                enemy.hit = 15;
                stunEnemy(enemy);
                // Cancel laser charging/targeting if hit
                if (enemy.laserCharging) {
                    enemy.laserCharging = false;
                    enemy.laserChargeTime = 0;
                    enemy.attackCooldown = 90; // Reset cooldown like melee attack
                }
                enemy.x += Math.cos(attackAngle) * knockback;
                enemy.y += Math.sin(attackAngle) * knockback;
                addWitchTimeCharge();
                return true;
            }
            return false;
        }

        function checkConeHit(enemy, playerX, playerY, coneAngle, coneArc, coneRange, damage, knockback) {
            const dx = enemy.x - playerX;
            const dy = enemy.y - playerY;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const hitRadius = enemy.size / 2;
            if (dist < coneRange + hitRadius) {
                let angle = Math.atan2(dy, dx);
                let angleDiff = angle - coneAngle;
                while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                if (Math.abs(angleDiff) < coneArc / 2) {
                    // x2 damage during witch time
                    const inWitchTime = game.witchTime.active && !game.witchTime.circleWipe;
                    const finalDamage = inWitchTime ? damage * 2 : damage;
                    enemy.health -= finalDamage;
                    enemy.hit = 15;
                    stunEnemy(enemy);
                    // Cancel laser charging/targeting if hit
                    if (enemy.laserCharging) {
                        enemy.laserCharging = false;
                        enemy.laserChargeTime = 0;
                        enemy.attackCooldown = 90;
                    }
                    enemy.x += Math.cos(angle) * knockback;
                    enemy.y += Math.sin(angle) * knockback;
                    addWitchTimeCharge();
                    return true;
                }
            }
            return false;
        }

        function checkArcHit(enemy, playerX, playerY, attackAngle, arc, range, damage, knockback) {
            const dx = enemy.x - playerX;
            const dy = enemy.y - playerY;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const hitRadius = enemy.size / 2;
            if (dist < range + hitRadius) {
                let angle = Math.atan2(dy, dx);
                const hitAngleStart = attackAngle - arc / 2;
                const hitAngleEnd = attackAngle + arc / 2;
                while (angle < hitAngleStart - Math.PI) angle += Math.PI * 2;
                while (angle > hitAngleStart + Math.PI) angle -= Math.PI * 2;
                if (angle >= hitAngleStart && angle <= hitAngleEnd) {
                    // x2 damage during witch time
                    const inWitchTime = game.witchTime.active && !game.witchTime.circleWipe;
                    const finalDamage = inWitchTime ? damage * 2 : damage;
                    enemy.health -= finalDamage;
                    enemy.hit = 15;
                    enemy.hitBounce = 1.0;  // Start bounce animation
                    enemy.hitBounceType = 'melee';
                    stunEnemy(enemy);
                    // Cancel laser charging/targeting if hit
                    if (enemy.laserCharging) {
                        enemy.laserCharging = false;
                        enemy.laserChargeTime = 0;
                        enemy.attackCooldown = 90;
                    }
                    const knockAngle = Math.atan2(dy, dx);
                    enemy.x += Math.cos(knockAngle) * Math.min(knockback, dist * 0.4);
                    enemy.y += Math.sin(knockAngle) * Math.min(knockback, dist * 0.4);
                    addWitchTimeCharge();
                    return { hit: true, knockAngle };
                }
            }
            return { hit: false };
        }

        function stopDash() {
            const player = game.player;
            player.isDashing = false;
            player.dashDuration = 0;
            player.vx = 0;
            player.vy = 0;
            player.movementPause = 12;
            player.dashMomentum = 0;
        }

        function startParry(target) {
            const player = game.player;
            const enemy = target.enemy;
            
            // Cancel enemy attack
            enemy.isCharging = false;
            enemy.chargeTime = 0;
            enemy.inParryWindow = false;
            enemy.hasBlinked = false;
            enemy.isStunned = true;
            enemy.stunTimer = 300; // Stunned for duration of witch time
            
            // Stun all nearby enemies too
            game.enemies.forEach(e => {
                if (e.health <= 0 || e.dead) return;
                const dx = e.x - player.x;
                const dy = e.y - player.y;
                if (Math.sqrt(dx * dx + dy * dy) < 300) {
                    e.isStunned = true;
                    e.stunTimer = 300;
                    e.isCharging = false;
                    e.chargeTime = 0;
                    e.inParryWindow = false;
                    e.hasBlinked = false;
                }
            });
            
            // Activate Witch Time
            game.witchTime.active = true;
            game.witchTime.timer = game.witchTime.maxTime;
            game.witchTime.perfectClear = false;
            game.witchTime.perfectClearTimer = 0;
            game.slowMotion = 0.15;
            game.violetFilter = 0.4;

            // Zoom IN for dramatic effect
            camera.targetZoom = camera.witchTimeZoom;
            
            // Circle wipe expanding FROM player (opening animation)
            const maxDimension = Math.max(GAME_AREA_WIDTH, GAME_AREA_HEIGHT);
            game.witchTime.circleWipe = {
                radius: 0,
                targetRadius: maxDimension,
                speed: maxDimension / 20, // ~20 frames
                centerX: player.x,
                centerY: player.y,
                expanding: true // Flag to indicate this is opening, not closing
            };
            
            // Consume witch time charge and disable charging
            game.witchTimeCharge.charge = 0;
            game.witchTimeCharge.ready = false;
            game.witchTimeCharge.canCharge = false; // Can't charge during witch time
            
            // SINGLE charged slash effect centered on player (not per-enemy)
            createSlashEffect(chargedMeleeAttack, player.angle, player.x, player.y, false, true);
            
            // Auto-slice ALL enemies in attack range at activation (one-time effect)
            const activationSliceRange = 300; // Large range for satisfying kills
            game.enemies.forEach(e => {
                if (e.health <= 0 || e.dead) return;
                const dx = e.x - player.x;
                const dy = e.y - player.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < activationSliceRange) {
                    // Apply massive damage (3x charged) - kills most enemies instantly
                    const tripleChargeDamage = chargedMeleeAttack.damage * 3;
                    e.health -= tripleChargeDamage;
                    e.hit = 15;

                    // Visual feedback
                    spawnParticles(e.x, e.y, '#ff00ff', 25, 12);
                    spawnShockwave(e.x, e.y, '#ff00ff', 70);

                    // Use killEnemy so pieces are properly cuttable during witch time
                    if (e.health <= 0) {
                        killEnemy(e, player.x, player.y, true);
                    }
                }
            });
            
            // Big hitfreeze for activation impact (same as charged attack)
            game.hitFreeze = 15;
            game.screenShake = 20;

            // WITCH TIME ACTIVATION EMPHASIS
            // Large expanding shockwave (~50% of viewport)
            spawnShockwave(player.x, player.y, '#ff00ff', 400);
            spawnShockwave(player.x, player.y, '#8800ff', 300);
            spawnShockwave(player.x, player.y, '#ffffff', 200);

            // Burst of purple/magenta particles radiating outward
            for (let i = 0; i < 30; i++) {
                const angle = (i / 30) * Math.PI * 2;
                const speed = 8 + Math.random() * 6;
                const color = Math.random() > 0.5 ? '#ff00ff' : '#aa00ff';
                game.particles.push({
                    x: player.x,
                    y: player.y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 40 + Math.random() * 20,
                    maxLife: 60,
                    radius: 4 + Math.random() * 4,
                    color
                });
            }
            
            // Small dash towards enemy
            player.dashAngle = Math.atan2(enemy.y - player.y, enemy.x - player.x);
            player.vx = Math.cos(player.dashAngle) * 15;
            player.vy = Math.sin(player.dashAngle) * 15;
            player.isDashing = true;
            player.dashDuration = 15;
            
            spawnDust(player.x, player.y, player.dashAngle);
        }

        // Manual witch time activation (P key / R2 when charged)
        function activateWitchTimeManual() {
            const player = game.player;

            // Stun all nearby enemies
            game.enemies.forEach(e => {
                if (e.health <= 0 || e.dead) return;
                const dx = e.x - player.x;
                const dy = e.y - player.y;
                if (Math.sqrt(dx * dx + dy * dy) < 300) {
                    e.isStunned = true;
                    e.stunTimer = 300;
                    e.isCharging = false;
                    e.chargeTime = 0;
                    e.inParryWindow = false;
                    e.hasBlinked = false;
                    e.laserCharging = false;
                    e.laserChargeTime = 0;
                }
            });

            // Activate Witch Time
            game.witchTime.active = true;
            game.witchTime.timer = game.witchTime.maxTime;
            game.witchTime.perfectClear = false;
            game.witchTime.perfectClearTimer = 0;
            game.slowMotion = 0.15;
            game.violetFilter = 0.4;

            // Zoom IN for dramatic effect
            camera.targetZoom = camera.witchTimeZoom;

            // Circle wipe expanding FROM player (opening animation)
            const maxDimension = Math.max(GAME_AREA_WIDTH, GAME_AREA_HEIGHT);
            game.witchTime.circleWipe = {
                radius: 0,
                targetRadius: maxDimension,
                speed: maxDimension / 20,
                centerX: player.x,
                centerY: player.y,
                expanding: true
            };

            // Consume witch time charge
            game.witchTimeCharge.charge = 0;
            game.witchTimeCharge.ready = false;
            game.witchTimeCharge.canCharge = false;

            // Slash effect
            createSlashEffect(chargedMeleeAttack, player.angle, player.x, player.y, false, true);

            // Auto-slice enemies in range - create suspended pieces directly
            const activationSliceRange = 300;
            game.enemies.forEach(e => {
                if (e.health <= 0 || e.dead) return;
                const dx = e.x - player.x;
                const dy = e.y - player.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < activationSliceRange) {
                    const tripleChargeDamage = chargedMeleeAttack.damage * 3;
                    e.health -= tripleChargeDamage;
                    e.hit = 15;
                    spawnParticles(e.x, e.y, '#ff00ff', 25, 12);
                    spawnShockwave(e.x, e.y, '#ff00ff', 70);
                    if (e.health <= 0) {
                        // Mark enemy as dead and handle XP/respawn
                        e.dead = true;
                        if (e.type === ENEMY_BOSS) {
                            e.respawnTimer = 400 + Math.random() * 200;
                            game.bossActive = false;
                        } else {
                            e.respawnTimer = 200 + Math.random() * 150;
                        }
                        addXP(e.type);

                        // Create pieces directly in 'suspended' state for witch time activation
                        if (game.slashDeaths.length < 15) {
                            const slashAngle = Math.atan2(player.y - e.y, player.x - e.x);
                            game.slashDeaths.push({
                                x: e.x, y: e.y, size: e.size, color: e.color, type: e.type,
                                slashAngle, phase: 'suspended', timer: 0, separation: 40,
                                finalSep: 40 // Already separated
                            });
                        }
                    }
                }
            });

            // Visual effects
            game.hitFreeze = 15;
            game.screenShake = 20;
            spawnShockwave(player.x, player.y, '#ff00ff', 400);
            spawnShockwave(player.x, player.y, '#8800ff', 300);
            spawnShockwave(player.x, player.y, '#ffffff', 200);

            // Burst of particles
            for (let i = 0; i < 30; i++) {
                const angle = (i / 30) * Math.PI * 2;
                const speed = 8 + Math.random() * 6;
                const color = Math.random() > 0.5 ? '#ff00ff' : '#aa00ff';
                game.particles.push({
                    x: player.x,
                    y: player.y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 40 + Math.random() * 20,
                    maxLife: 60,
                    radius: 4 + Math.random() * 4,
                    color
                });
            }
        }

        function endWitchTime() {
            const player = game.player;
            
            // Start circle wipe animation (closes inward to player)
            const maxDimension = Math.max(GAME_AREA_WIDTH, GAME_AREA_HEIGHT);
            game.witchTime.circleWipe = {
                radius: maxDimension,
                targetRadius: 0,
                speed: maxDimension / 20, // ~20 frames
                centerX: player.x,
                centerY: player.y,
                expanding: false // Closing animation
            };

            // Restore normal zoom
            camera.targetZoom = camera.normalZoom;
        }

        function updateWitchTime(timeScale) {
            if (!game.witchTime.active) return;
            
            // Circle wipe animation (expanding or closing)
            if (game.witchTime.circleWipe) {
                const wipe = game.witchTime.circleWipe;
                
                if (wipe.expanding) {
                    // Opening animation - expand from 0 to full screen
                    wipe.radius += wipe.speed;
                    
                    if (wipe.radius >= wipe.targetRadius) {
                        // Expansion complete - remove wipe and start normal witch time
                        game.witchTime.circleWipe = null;
                    }
                } else {
                    // Closing animation - shrink from full to 0
                    wipe.radius -= wipe.speed;
                    
                    if (wipe.radius <= 0) {
                        // End witch time completely
                        game.witchTime.active = false;
                        game.witchTime.circleWipe = null;
                        game.slowMotion = 1;
                        game.violetFilter = 0;
                        // Re-enable charging
                        game.witchTimeCharge.canCharge = true;
                    }
                }
                return;
            }
            
            // Count down timer (in real time, not slow-mo time)
            game.witchTime.timer -= 1;
            
            // Flash warning when about to end
            if (game.witchTime.timer < 60) {
                game.violetFilter = 0.4 + Math.sin(game.witchTime.timer * 0.3) * 0.2;
            }
            
            if (game.witchTime.timer <= 0) {
                endWitchTime();
            }
        }

        // Track enemy pieces for recursive cutting
        const enemyPieces = [];

        function createEnemyPiece(x, y, size, color, type, health = 1) {
            return {
                x, y, size, color, type, health,
                angle: Math.random() * Math.PI * 2,
                vx: 0, vy: 0,
                hit: 0
            };
        }

        function sliceEnemyOrPiece(target, slashAngle, isEnemy = true) {
            const player = game.player;
            
            // Restore witch time on kill
            if (game.witchTime.active && !game.witchTime.circleWipe) {
                game.witchTime.timer = Math.min(game.witchTime.maxTime, game.witchTime.timer + game.witchTime.killTimeBonus);
                game.witchTime.rechargeFlash = 20; // Flash the bar
            }

            if (isEnemy) {
                // Kill the enemy
                target.dead = true;
                // Longer respawn times, bosses take even longer
                if (target.type === ENEMY_BOSS) {
                    target.respawnTimer = 400 + Math.random() * 200;
                } else {
                    target.respawnTimer = 200 + Math.random() * 150;
                }
                if (target.type === ENEMY_BOSS) game.bossActive = false;
                addXP(target.type);
                
                // Create pieces if under limit
                if (enemyPieces.length < 30) {
                    const piece1 = createEnemyPiece(target.x, target.y, target.size * 0.7, target.color, target.type);
                    const piece2 = createEnemyPiece(target.x, target.y, target.size * 0.7, target.color, target.type);
                    
                    const perpAngle = slashAngle + Math.PI / 2;
                    piece1.vx = Math.cos(perpAngle) * 3;
                    piece1.vy = Math.sin(perpAngle) * 3;
                    piece2.vx = -Math.cos(perpAngle) * 3;
                    piece2.vy = -Math.sin(perpAngle) * 3;
                    piece1.cutAngle = slashAngle;
                    piece2.cutAngle = slashAngle;
                    piece1.side = 1;
                    piece2.side = -1;
                    
                    enemyPieces.push(piece1, piece2);
                }
            } else {
                // Slice a piece into smaller pieces
                target.health = 0;
                
                // Only subdivide if piece is big enough and under limit
                if (target.size > 15 && enemyPieces.length < 30) {
                    const piece1 = createEnemyPiece(target.x, target.y, target.size * 0.7, target.color, target.type);
                    const piece2 = createEnemyPiece(target.x, target.y, target.size * 0.7, target.color, target.type);
                    
                    const perpAngle = slashAngle + Math.PI / 2;
                    piece1.vx = target.vx + Math.cos(perpAngle) * 2;
                    piece1.vy = target.vy + Math.sin(perpAngle) * 2;
                    piece2.vx = target.vx - Math.cos(perpAngle) * 2;
                    piece2.vy = target.vy - Math.sin(perpAngle) * 2;
                    piece1.cutAngle = slashAngle;
                    piece2.cutAngle = slashAngle;
                    piece1.side = 1;
                    piece2.side = -1;
                    
                    enemyPieces.push(piece1, piece2);
                }
                
                spawnParticles(target.x, target.y, target.color, 5, 3);
            }
            
            // Slash death effect - use 'flash' phase so pieces can be cut during witch time
            if (game.slashDeaths.length < 20) {
                game.slashDeaths.push({
                    x: target.x, y: target.y,
                    size: target.size,
                    color: target.color,
                    type: target.type,
                    slashAngle: slashAngle,
                    phase: 'flash', // Use flash so it transitions to split->suspended (cuttable)
                    timer: 0,
                    separation: 0
                });
            }
            
            spawnParticles(target.x, target.y, '#ffffff', 6, 4);
            game.screenShake = 6;
            game.hitFreeze = 4;
        }

        function executeParryDash() {
            const player = game.player;
            player.vx = Math.cos(player.dashAngle) * player.dashSpeed;
            player.vy = Math.sin(player.dashAngle) * player.dashSpeed;
            player.isDashing = true;
            player.dashDuration = 45;
            game.slowMotion = 0.15;
            game.slowMotionTimer = 150;
            game.violetFilter = 0.6;
            
            spawnDust(player.x, player.y, player.dashAngle);
            addGhostTrail();
        }

        function endParry() {
            const player = game.player;
            game.slowMotion = 1;
            game.violetFilter = 0;
            game.parryCircle = null;
            player.isParrying = false;
            player.parryTarget = null;
            player.parryTargets = [];
            player.dashSpeed = player.baseDashSpeed;
        }

        function chargedDashMeleeAttack() {
            const player = game.player;
            player.dashMeleeUsed = true;
            // Use dashAngle if dashing, otherwise use player.angle
            const thrustAngle = player.isDashing ? player.dashAngle : player.angle;
            
            // Larger offset so spikes don't overlap at origin
            const baseOffset = dashMeleeAttack.offset + 20;
            
            // Main spike (center)
            createThrustEffect(player.x, player.y, thrustAngle, dashMeleeAttack.width, dashMeleeAttack.length, baseOffset, dashMeleeAttack.duration, dashMeleeAttack.color);
            
            // Side spikes with more spread (45 degrees instead of ~23)
            createThrustEffect(player.x, player.y, thrustAngle + Math.PI * 0.3, dashMeleeAttack.width * 0.85, dashMeleeAttack.length * 0.9, baseOffset + 10, dashMeleeAttack.duration, dashMeleeAttack.color);
            createThrustEffect(player.x, player.y, thrustAngle - Math.PI * 0.3, dashMeleeAttack.width * 0.85, dashMeleeAttack.length * 0.9, baseOffset + 10, dashMeleeAttack.duration, dashMeleeAttack.color);
            
            // Inner spikes
            createThrustEffect(player.x, player.y, thrustAngle + Math.PI * 0.15, dashMeleeAttack.width * 0.7, dashMeleeAttack.length * 0.75, baseOffset + 5, dashMeleeAttack.duration, dashMeleeAttack.color);
            createThrustEffect(player.x, player.y, thrustAngle - Math.PI * 0.15, dashMeleeAttack.width * 0.7, dashMeleeAttack.length * 0.75, baseOffset + 5, dashMeleeAttack.duration, dashMeleeAttack.color);
            
            createSlashEffect(chargedMeleeAttack, thrustAngle, player.x, player.y, false, true);
            if (player.isDashing) stopDash();
            
            let hitSomething = false;
            game.enemies.forEach(enemy => {
                if (enemy.health <= 0 || enemy.dead) return;
                if (checkConeHit(enemy, player.x, player.y, thrustAngle, chargedDashCone.angle, chargedDashCone.range, chargedDashCone.damage, chargedMeleeAttack.knockback)) {
                    hitSomething = true;
                    spawnParticles(enemy.x, enemy.y, chargedMeleeAttack.color, 20, 10);
                    if (enemy.health <= 0) killEnemy(enemy, player.x, player.y);
                }
            });
            
            // Same freeze behavior in and out of witch time
            if (hitSomething) { 
                game.hitFreeze = 15; 
                game.screenShake = 12; 
            }
            player.meleeCooldown = 20;
        }

        function dashMeleeAttackHit() {
            const player = game.player;
            player.dashMeleeUsed = true;
            // Use dashAngle if dashing, otherwise use player.angle (for witch time thrusts)
            const thrustAngle = player.isDashing ? player.dashAngle : player.angle;
            createThrustEffect(player.x, player.y, thrustAngle, dashMeleeAttack.width, dashMeleeAttack.length, dashMeleeAttack.offset, dashMeleeAttack.duration, dashMeleeAttack.color);
            if (player.isDashing) stopDash();
            let hitSomething = false;
            game.enemies.forEach(enemy => {
                if (enemy.health <= 0 || enemy.dead) return;
                if (checkThrustHit(enemy, player.x, player.y, thrustAngle, dashMeleeAttack.length, dashMeleeAttack.width, dashMeleeAttack.offset, dashMeleeAttack.damage, dashMeleeAttack.knockback)) {
                    hitSomething = true;
                    spawnParticles(enemy.x, enemy.y, dashMeleeAttack.color, 15, 8);
                    if (enemy.health <= 0) killEnemy(enemy, player.x, player.y);
                }
            });
            // Same freeze behavior in and out of witch time
            if (hitSomething) { 
                game.hitFreeze = 10; 
                game.screenShake = 8; 
            }
            // Add small cooldown for thrust
            player.meleeCooldown = 15;
        }

        function executeMeleeAttack(isCharged) {
            const player = game.player;

            // Combo system - 3rd hit is special (only for normal attacks, not charged)
            let isComboFinisher = false;
            if (!isCharged) {
                player.meleeComboCount = (player.meleeComboCount + 1) % 3;
                isComboFinisher = (player.meleeComboCount === 0); // 0 means we just did hit 3
                player.comboResetTimer = 45; // Reset combo after ~0.75 sec of no attacks
            } else {
                // Charged attacks reset combo
                player.meleeComboCount = 0;
            }
            player.lastMeleeWasComboFinisher = isComboFinisher;

            // Get base attack, modify if combo finisher
            let attack = isCharged ? chargedMeleeAttack : meleeAttack;
            if (isComboFinisher && !isCharged) {
                // Combo finisher: 1.5x damage, slightly larger, violet color
                attack = {
                    ...meleeAttack,
                    damage: meleeAttack.damage * 1.5,
                    range: meleeAttack.range * 1.15,
                    arc: meleeAttack.arc * 1.1,
                    color: '#aa44ff' // Violet
                };
            }

            player.meleeFrame = attack.duration;
            player.meleeCooldown = attack.cooldown;
            player.lastMeleeWasCharged = isCharged; // Track for laser deflect

            // Find closest enemy for melee targeting (priority: live enemies > suspended pieces)
            let closestEnemy = null;
            let closestDist = Infinity;
            game.enemies.forEach(enemy => {
                if (enemy.health <= 0 || enemy.dead) return;
                const dx = enemy.x - player.x;
                const dy = enemy.y - player.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < closestDist) {
                    closestDist = dist;
                    closestEnemy = enemy;
                }
            });

            // During witch time, increase melee range and arc. Outside witch time, reduce range slightly.
            const inWitchTime = game.witchTime.active && !game.witchTime.circleWipe;
            const witchTimeRangeBonus = inWitchTime ? 40 : -15;  // +40 range in WT, -15 outside
            const witchTimeArcBonus = inWitchTime ? 0.3 : 0;   // +0.3 rad arc in WT
            const effectiveRange = attack.range + witchTimeRangeBonus;
            const effectiveArc = attack.arc + witchTimeArcBonus;

            // If no live enemies nearby, check for suspended pieces during witch time
            let meleeAngle = player.angle;
            if (closestEnemy) {
                meleeAngle = Math.atan2(closestEnemy.y - player.y, closestEnemy.x - player.x);
            } else if (inWitchTime) {
                // Find closest cuttable piece (suspended or half) to auto-aim at
                let closestPieceDist = Infinity;
                let closestPiecePos = null;
                const autoAimRange = effectiveRange + 100; // Much larger detection range for auto-aim

                game.slashDeaths.forEach(death => {
                    // Handle 'flash', 'split' or 'suspended' phase (two halves together)
                    if ((death.phase === 'flash' || death.phase === 'split' || death.phase === 'suspended') && death.size >= 8) {
                        const perpAngle = death.slashAngle + Math.PI / 2;
                        const sep = death.finalSep || death.separation;

                        // Check both halves
                        const halves = [
                            { x: death.x + Math.cos(perpAngle) * sep, y: death.y + Math.sin(perpAngle) * sep },
                            { x: death.x - Math.cos(perpAngle) * sep, y: death.y - Math.sin(perpAngle) * sep }
                        ];

                        halves.forEach(half => {
                            const dx = half.x - player.x;
                            const dy = half.y - player.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist < closestPieceDist && dist < autoAimRange) {
                                closestPieceDist = dist;
                                closestPiecePos = half;
                            }
                        });
                    }
                    // Handle 'half' phase (single half that can still be cut)
                    else if (death.phase === 'half' && death.size >= 8) {
                        const dx = death.x - player.x;
                        const dy = death.y - player.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < closestPieceDist && dist < autoAimRange) {
                            closestPieceDist = dist;
                            closestPiecePos = { x: death.x, y: death.y };
                        }
                    }
                });

                if (closestPiecePos) {
                    meleeAngle = Math.atan2(closestPiecePos.y - player.y, closestPiecePos.x - player.x);
                }
            }
            
            // Create slash effect with WT bonus (visual also bigger)
            const slashAttack = inWitchTime ? { ...attack, arc: effectiveArc, range: effectiveRange } : attack;
            createSlashEffect(slashAttack, meleeAngle, player.x, player.y, true, isCharged);
            let hitSomething = false;

            // Hit enemies - use effective range/arc during witch time
            game.enemies.forEach(enemy => {
                if (enemy.health <= 0 || enemy.dead) return;
                const result = checkArcHit(enemy, player.x, player.y, meleeAngle, effectiveArc, effectiveRange, attack.damage, attack.knockback);
                if (result.hit) {
                    hitSomething = true;
                    spawnParticles(enemy.x, enemy.y, attack.color, isCharged ? 20 : 12, isCharged ? 10 : 6);
                    if (enemy.health <= 0) killEnemy(enemy, player.x, player.y);
                }
            });

            // During witch time: re-cut suspended enemy pieces AND single halves
            // For pieces: use CIRCULAR hit area (no arc check) - makes cutting much easier
            const pieceHitRange = effectiveRange + (isCharged ? 40 : 20);

            if (game.witchTime.active) {
                const piecesToAdd = [];
                game.slashDeaths = game.slashDeaths.filter(death => {
                    // Handle 'flash' and 'split' phases - can cut during appearance animation!
                    if ((death.phase === 'flash' || death.phase === 'split') && death.size >= 8) {
                        const perpAngle = death.slashAngle + Math.PI / 2;
                        const sep = death.separation;

                        // Calculate positions of both halves
                        const half1X = death.x + Math.cos(perpAngle) * sep;
                        const half1Y = death.y + Math.sin(perpAngle) * sep;
                        const half2X = death.x - Math.cos(perpAngle) * sep;
                        const half2Y = death.y - Math.sin(perpAngle) * sep;

                        // Check which half (if any) the melee hits - CIRCULAR hit area (no arc check)
                        let hitHalf = -1;
                        let hitX, hitY;
                        const hitRange = pieceHitRange + death.size;

                        for (let h = 0; h < 2; h++) {
                            const hx = h === 0 ? half1X : half2X;
                            const hy = h === 0 ? half1Y : half2Y;

                            const dx = hx - player.x;
                            const dy = hy - player.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);

                            // Only distance check - full 360 degree hit area for pieces
                            if (dist < hitRange) {
                                hitHalf = h;
                                hitX = hx;
                                hitY = hy;
                                break;
                            }
                        }

                        if (hitHalf >= 0) {
                            // Hit during split! Create 2 quarter pieces
                            const newSize = death.size * 0.55;
                            const newSlashAngle = meleeAngle;
                            const newPerpAngle = newSlashAngle + Math.PI / 2;

                            if (newSize >= 8) {
                                for (let i = 0; i < 2; i++) {
                                    const side = i === 0 ? 1 : -1;
                                    piecesToAdd.push({
                                        x: hitX + Math.cos(newPerpAngle) * 8 * side,
                                        y: hitY + Math.sin(newPerpAngle) * 8 * side,
                                        size: newSize,
                                        type: death.type,
                                        color: death.color,
                                        slashAngle: newSlashAngle,
                                        cutSide: side,
                                        phase: 'quarter',
                                        timer: 0,
                                        vx: Math.cos(newPerpAngle) * 2 * side,
                                        vy: Math.sin(newPerpAngle) * 2 * side
                                    });
                                }
                            } else {
                                spawnParticles(hitX, hitY, death.color, 8, 4);
                            }

                            // Keep the other half as cuttable
                            const otherX = hitHalf === 0 ? half2X : half1X;
                            const otherY = hitHalf === 0 ? half2Y : half1Y;
                            const otherSide = hitHalf === 0 ? -1 : 1;
                            piecesToAdd.push({
                                x: otherX,
                                y: otherY,
                                size: death.size,
                                type: death.type,
                                color: death.color,
                                slashAngle: death.slashAngle,
                                cutSide: otherSide,
                                phase: 'half',
                                timer: 0,
                                vx: 0, vy: 0
                            });

                            spawnParticles(hitX, hitY, death.color, 10, 5);
                            spawnParticles(hitX, hitY, '#ffffff', 6, 3);
                            game.screenShake = Math.max(game.screenShake, 5);
                            hitSomething = true;
                            return false;
                        }
                        return true;
                    }

                    // Handle 'suspended' phase (two halves together)
                    if (death.phase === 'suspended' && death.size >= 8) {
                        // The suspended slashDeath has two halves at fixed positions
                        const perpAngle = death.slashAngle + Math.PI / 2;
                        const sep = death.finalSep || death.separation;

                        // Calculate positions of both halves
                        const half1X = death.x + Math.cos(perpAngle) * sep;
                        const half1Y = death.y + Math.sin(perpAngle) * sep;
                        const half2X = death.x - Math.cos(perpAngle) * sep;
                        const half2Y = death.y - Math.sin(perpAngle) * sep;

                        // Check which half (if any) the melee hits - CIRCULAR hit area (no arc check)
                        let hitHalf = -1;
                        let hitX, hitY;
                        const hitRange = pieceHitRange + death.size;

                        for (let h = 0; h < 2; h++) {
                            const hx = h === 0 ? half1X : half2X;
                            const hy = h === 0 ? half1Y : half2Y;

                            const dx = hx - player.x;
                            const dy = hy - player.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);

                            // Only distance check - full 360 degree hit area for pieces
                            if (dist < hitRange) {
                                hitHalf = h;
                                hitX = hx;
                                hitY = hy;
                                break;
                            }
                        }

                        if (hitHalf >= 0) {
                            // Hit a half! Create 2 quarter pieces from this half
                            const newSize = death.size * 0.55;
                            const newSlashAngle = meleeAngle;
                            const newPerpAngle = newSlashAngle + Math.PI / 2;

                            // Create 2 quarter pieces flying apart
                            if (newSize >= 8) {
                                for (let i = 0; i < 2; i++) {
                                    const side = i === 0 ? 1 : -1;
                                    piecesToAdd.push({
                                        x: hitX + Math.cos(newPerpAngle) * 8 * side,
                                        y: hitY + Math.sin(newPerpAngle) * 8 * side,
                                        size: newSize,
                                        type: death.type,
                                        color: death.color,
                                        slashAngle: newSlashAngle,
                                        cutSide: side,
                                        phase: 'quarter', // Mark as quarter (cannot be cut again)
                                        timer: 0,
                                        vx: Math.cos(newPerpAngle) * 2 * side,
                                        vy: Math.sin(newPerpAngle) * 2 * side
                                    });
                                }
                            } else {
                                spawnParticles(hitX, hitY, death.color, 8, 4);
                            }

                            // Keep the other half as a cuttable 'half' piece
                            const otherX = hitHalf === 0 ? half2X : half1X;
                            const otherY = hitHalf === 0 ? half2Y : half1Y;
                            const otherSide = hitHalf === 0 ? -1 : 1;
                            piecesToAdd.push({
                                x: otherX,
                                y: otherY,
                                size: death.size,
                                type: death.type,
                                color: death.color,
                                slashAngle: death.slashAngle,
                                cutSide: otherSide,
                                phase: 'half', // Single half - can still be cut into quarters
                                timer: 0,
                                vx: 0, vy: 0
                            });

                            // Effects
                            spawnParticles(hitX, hitY, death.color, 10, 5);
                            spawnParticles(hitX, hitY, '#ffffff', 6, 3);
                            game.screenShake = Math.max(game.screenShake, 5);
                            hitSomething = true;
                            return false; // Remove original
                        }
                        return true;
                    }

                    // Handle 'half' phase (single half that can be cut into quarters)
                    if (death.phase === 'half' && death.size >= 8) {
                        const dx = death.x - player.x;
                        const dy = death.y - player.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const hitRange = pieceHitRange + death.size;

                        // CIRCULAR hit area - only distance check, no arc (full 360 degrees)
                        if (dist < hitRange) {
                            // Cut this half into 2 quarters
                            const newSize = death.size * 0.55;
                            const newSlashAngle = meleeAngle;
                            const newPerpAngle = newSlashAngle + Math.PI / 2;

                            if (newSize >= 8) {
                                for (let i = 0; i < 2; i++) {
                                    const side = i === 0 ? 1 : -1;
                                    piecesToAdd.push({
                                        x: death.x + Math.cos(newPerpAngle) * 8 * side,
                                        y: death.y + Math.sin(newPerpAngle) * 8 * side,
                                        size: newSize,
                                        type: death.type,
                                        color: death.color,
                                        slashAngle: newSlashAngle,
                                        cutSide: side,
                                        phase: 'quarter', // Mark as quarter (cannot be cut again)
                                        timer: 0,
                                        vx: Math.cos(newPerpAngle) * 2 * side,
                                        vy: Math.sin(newPerpAngle) * 2 * side
                                    });
                                }
                            } else {
                                spawnParticles(death.x, death.y, death.color, 8, 4);
                            }

                            // Effects
                            spawnParticles(death.x, death.y, death.color, 10, 5);
                            spawnParticles(death.x, death.y, '#ffffff', 6, 3);
                            game.screenShake = Math.max(game.screenShake, 5);
                            hitSomething = true;
                            return false; // Remove original half
                        }
                        return true;
                    }

                    return true;
                });

                // Add new pieces
                piecesToAdd.forEach(p => game.slashDeaths.push(p));
            }

            if (hitSomething) {
                // Same freeze behavior in and out of witch time
                game.hitFreeze = isCharged ? 15 : 6;
                game.screenShake = isCharged ? 12 : 6;
            }
        }

        function startChargingMelee() {
            const player = game.player;
            if (!player.isChargingMelee && player.meleeCooldown <= 0 && player.cantAttackTimer <= 0) {
                player.isChargingMelee = true;
                player.meleeChargeTime = 0;
                player.chargeReady = false;
            }
        }

        function releaseMelee() {
            const player = game.player;
            
            if (player.isChargingMelee) {
                const isFullyCharged = player.chargeReady;
                // Always do normal melee attack (no thrusts)
                if (player.meleeCooldown <= 0 && player.cantAttackTimer <= 0 && !player.isDashing) {
                    executeMeleeAttack(isFullyCharged);
                }
                player.isChargingMelee = false;
                player.meleeChargeTime = 0;
                player.chargeReady = false;
            }
        }

        function shoot() {
            const player = game.player;
            if (player.cantAttackTimer > 0 || player.isKnockedBack || player.isGrounded) return;

            // Only shoot if there's a visible target (autoAimTarget is set and on screen)
            if (!player.autoAimTarget || !isEnemyOnScreen(player.autoAimTarget)) return;

            const now = Date.now();
            if (now - game.lastShot < game.weapon.fireRate) return;
            game.lastShot = now;

            // Calculate aim angle directly toward autoAimTarget (independent of melee direction)
            const target = player.autoAimTarget;
            const aimAngle = Math.atan2(target.y - player.y, target.x - player.x);

            // Fire multiple bullets for shotgun
            const bulletsToFire = game.weapon.bulletsPerShot || 1;
            for (let i = 0; i < bulletsToFire; i++) {
                const spread = (Math.random() - 0.5) * game.weapon.spread * 2;
                const angle = aimAngle + spread;
                game.bullets.push({
                    x: player.x + Math.cos(aimAngle) * 25, y: player.y + Math.sin(aimAngle) * 25,
                    vx: Math.cos(angle) * game.weapon.bulletSpeed, vy: Math.sin(angle) * game.weapon.bulletSpeed,
                    angle, damage: game.weapon.damage, color: game.weapon.color, life: 60
                });
            }
            game.screenShake = bulletsToFire > 1 ? 4 : 2;
            spawnParticles(player.x + Math.cos(aimAngle) * 30, player.y + Math.sin(aimAngle) * 30, game.weapon.color, bulletsToFire > 1 ? 4 : 2);
        }

        function dash() {
            const player = game.player;
            if (player.isKnockedBack || player.isGrounded) return;
            
            // During witch time, can't trigger another witch time
            if (game.witchTime.active) {
                // Normal dash during witch time
                if (player.isDashing) return;
                player.isDashing = true;
                player.dashDuration = 20;
                player.dashAngle = game.hasMoveInput ? game.currentMoveAngle : player.angle;
                player.vx = Math.cos(player.dashAngle) * 18;
                player.vy = Math.sin(player.dashAngle) * 18;
                spawnDust(player.x, player.y, player.dashAngle);
                return;
            }
            
            if (player.isDashing) spawnDust(player.x, player.y, player.dashAngle);
            
            let dashAngle = game.hasMoveInput ? game.currentMoveAngle : player.angle;

            // Check for parry targets (enemies in parryWindow - charging melee attack)
            if (game.witchTimeCharge.ready) {
                const parryTarget = findParryTarget(dashAngle);
                if (parryTarget) {
                    startParry(parryTarget);
                    return;
                }

                // Also check for enemies charging laser
                const laserTarget = findLaserChargingEnemy();
                if (laserTarget) {
                    // Cancel the enemy's laser
                    laserTarget.enemy.laserCharging = false;
                    laserTarget.enemy.laserChargeTime = 0;
                    laserTarget.enemy.isStunned = true;
                    laserTarget.enemy.stunTimer = 120;

                    // Activate witch time
                    activateWitchTimeManual();

                    // Perform the dash as well
                    player.isDashing = true;
                    player.dashDuration = 25;
                    player.dashAngle = dashAngle;
                    player.vx = Math.cos(player.dashAngle) * 20;
                    player.vy = Math.sin(player.dashAngle) * 20;
                    spawnDust(player.x, player.y, player.dashAngle);
                    return;
                }
            }

            // Normal dash
            player.isDashing = true;
            player.dashDuration = 30;
            player.dashCooldown = 35;
            player.dashMeleeUsed = false;
            player.movementPause = 0;
            player.dashAngle = dashAngle;
            
            const currentSpeed = Math.sqrt(player.vx * player.vx + player.vy * player.vy);
            const momentumBonus = Math.min(currentSpeed * 0.5, 8);
            player.dashSpeed = player.baseDashSpeed + momentumBonus;
            player.dashMomentum = player.dashSpeed;
            
            player.vx = Math.cos(player.dashAngle) * player.dashSpeed;
            player.vy = Math.sin(player.dashAngle) * player.dashSpeed;
            
            spawnDust(player.x, player.y, player.dashAngle);
            addGhostTrail();
        }

        function buttonJustPressed(buttons, index) {
            return game.buttonsJustPressed[index] || false;
        }
        function buttonJustReleased(buttons, index) {
            return game.buttonsJustReleased[index] || false;
        }

        function enemyAttackPlayer(enemy) {
            const player = game.player;
            const attackConfig = enemy.type === ENEMY_BOSS ? bossAttack : enemyAttack;
            const dx = player.x - enemy.x;
            const dy = player.y - enemy.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const angleToPlayer = Math.atan2(dy, dx);
            
            if (dist < attackConfig.range + player.radius + 50) {
                damagePlayer(enemy.x, enemy.y, enemy.type === ENEMY_BOSS, enemy.type === ENEMY_BIG);
            }
            
            createSlashEffect({
                arc: attackConfig.arc * 0.8,
                duration: 12,
                range: attackConfig.range * 1.2,
                color: enemy.type === ENEMY_BOSS ? '#ffaa00' : '#ff4444'
            }, angleToPlayer, enemy.x, enemy.y, false);
            
            enemy.inParryWindow = false;
            enemy.hasBlinked = false;
            enemy.isCharging = false;
            enemy.chargeTime = 0;
            enemy.attackCooldown = 60;
            enemy.attackPause = attackConfig.attackPauseDuration;
        }

        function update(gamepad) {
            // Update keyboard state at start of frame
            updateKeyboardState();

            // Toggle pause with H key or Options button
            const optionsPressed = gamepad && buttonJustPressed(gamepad.buttons, 9);
            if (keysJustPressed['KeyH'] || optionsPressed) {
                game.paused = !game.paused;
            }

            // If paused, check for any input to resume
            if (game.paused) {
                // Any key/button resumes (except H which toggles)
                if (checkRestartInput(gamepad) && !keysJustPressed['KeyH'] && !optionsPressed) {
                    game.paused = false;
                }
                return;
            }

            // Handle death sequence
            if (game.death.active) {
                updatePlayerDeath();

                // Check for restart input during wait phase (phase 0)
                if (game.death.phase === 0 && game.death.canRestart) {
                    if (checkRestartInput(gamepad)) {
                        game.death.phase = 1;
                        game.death.timer = 0;
                    }
                }

                if (game.death.frozen) {
                    return; // Game frozen during death
                }
            }

            // Witch time runs in real-time for the timer
            updateWitchTime(1);

            // Perfect Clear check - if all enemies dead during witch time
            if (game.witchTime.active && !game.witchTime.circleWipe && !game.witchTime.perfectClear) {
                const allEnemiesDead = game.enemies.every(e => e.dead || e.health <= 0);
                if (allEnemiesDead) {
                    // Trigger Perfect Clear
                    game.witchTime.perfectClear = true;
                    game.witchTime.perfectClearTimer = 180; // 3 seconds for wave animation
                    game.witchTime.perfectClearWave = 0;    // Wave animation progress
                    game.screenShake = 20;
                }
            }

            // Handle Perfect Clear state
            if (game.witchTime.perfectClear) {
                game.witchTime.perfectClearTimer -= 1;
                // Advance wave animation
                if (game.witchTime.perfectClearWave !== undefined) {
                    game.witchTime.perfectClearWave += 1;
                }

                // Everything frozen during perfect clear
                if (game.witchTime.perfectClearTimer <= 0) {
                    // End perfect clear - exit witch time and ALL powerups +1
                    game.witchTime.active = false;
                    game.witchTime.perfectClear = false;
                    game.witchTime.circleWipe = null;
                    game.slowMotion = 1;
                    game.violetFilter = 0;
                    game.witchTimeCharge.canCharge = true;

                    // Restore normal zoom
                    camera.targetZoom = camera.normalZoom;

                    // Perfect Clear reward: ALL powerups +1 level!
                    ['melee', 'gun', 'dash', 'witchTime', 'regen'].forEach(type => {
                        applyPowerUp(type);
                    });
                }
                
                // Don't update anything else during perfect clear
                return;
            }
            
            // During witch time: enemies slow, player normal
            const inWitchTime = game.witchTime.active && !game.witchTime.circleWipe;
            const enemyTime = inWitchTime ? game.witchTime.enemySpeed : 1;
            const playerTime = 1; // Player always full speed
            
            if (game.screenShake > 0.5) game.screenShake *= 0.85; else game.screenShake = 0;

            game.shockwaves = game.shockwaves.filter(sw => {
                sw.life -= 1;
                sw.radius += ((sw.maxRadius - 20) / sw.maxLife);
                return sw.life > 0;
            });

            // Update enemy pieces - they move at player speed but suspend longer in witch time
            for (let i = enemyPieces.length - 1; i >= 0; i--) {
                const piece = enemyPieces[i];
                // Add lifetime if not set
                if (piece.lifetime === undefined) piece.lifetime = 180;
                piece.lifetime -= 1;
                
                // During witch time, pieces slow down faster (suspend effect)
                const friction = inWitchTime ? 0.92 : 0.95;
                piece.x += piece.vx;
                piece.y += piece.vy;
                piece.vx *= friction;
                piece.vy *= friction;
                if (piece.hit > 0) piece.hit -= 1;
                
                // Remove: lifetime expired or witch time ended
                if (piece.lifetime <= 0 || (!game.witchTime.active && !game.witchTime.circleWipe)) {
                    spawnParticles(piece.x, piece.y, piece.color, 6, 3);
                    enemyPieces.splice(i, 1);
                }
            }
            
            // Limit max pieces
            while (enemyPieces.length > 30) {
                enemyPieces.shift();
            }
            
            // Limit slashDeaths
            while (game.slashDeaths.length > 20) {
                game.slashDeaths.shift();
            }

            game.slashDeaths = game.slashDeaths.filter(death => {
                death.timer += 1;
                if (death.phase === 'line') {
                    if (death.timer > 20) return false;
                } else if (death.phase === 'flash') {
                    if (death.timer > 8) { death.phase = 'split'; death.timer = 0; }
                } else if (death.phase === 'split') {
                    // For suspension: also count expanding circleWipe as witch time (activation kills)
                    const shouldSuspend = inWitchTime || (game.witchTime.active && game.witchTime.circleWipe && game.witchTime.circleWipe.expanding);
                    // Faster separation in witch time so pieces can be cut sooner
                    death.separation += shouldSuspend ? 6 : 3;
                    if (death.timer > 6) { // Faster transition (was 15)
                        // In witch time: suspend the pieces instead of exploding
                        if (shouldSuspend && death.size >= 12) {
                            death.phase = 'suspended';
                            death.timer = 0;
                            // Store final positions of both halves
                            const perpAngle = death.slashAngle + Math.PI / 2;
                            death.finalSep = death.separation;
                        } else {
                            death.phase = 'explode'; death.timer = 0;
                            spawnParticles(death.x, death.y, '#ff0000', 10, 6);
                            spawnParticles(death.x, death.y, death.color, 8, 5);
                        }
                    }
                } else if (death.phase === 'suspended') {
                    // Pieces suspended in air during witch time - can be re-cut
                    // When witch time ends, explode (but stay alive during expanding circleWipe)
                    const staysSuspended = inWitchTime || (game.witchTime.active && game.witchTime.circleWipe && game.witchTime.circleWipe.expanding);
                    if (!staysSuspended) {
                        death.phase = 'explode'; death.timer = 0;
                        spawnParticles(death.x, death.y, '#ff0000', 10, 6);
                        spawnParticles(death.x, death.y, death.color, 8, 5);
                    }
                    // Stay suspended for a very long time (8 seconds) - will be cut or witch time ends
                    if (death.timer > 480) {
                        death.phase = 'explode'; death.timer = 0;
                        spawnParticles(death.x, death.y, death.color, 6, 4);
                    }
                } else if (death.phase === 'explode') {
                    if (death.timer > 5) return false;
                } else if (death.phase === 'piece' || death.phase === 'half' || death.phase === 'quarter') {
                    // Individual piece (half or quarter) floating
                    if (death.vx !== undefined) {
                        death.x += death.vx;
                        death.y += death.vy;
                        death.vx *= 0.9;
                        death.vy *= 0.9;
                    }
                    // Halves last much longer so player can cut them, quarters shorter
                    // Also count expanding circleWipe as witch time (activation kills)
                    const piecesInWitchTime = inWitchTime || (game.witchTime.active && game.witchTime.circleWipe && game.witchTime.circleWipe.expanding);
                    const isQuarter = death.phase === 'quarter' || death.size < 25;
                    const maxTime = piecesInWitchTime ? (isQuarter ? 90 : 360) : 30; // Halves: 6 sec, Quarters: 1.5 sec
                    if (death.timer > maxTime) {
                        spawnParticles(death.x, death.y, death.color, 6, 3);
                        return false;
                    }
                    // When witch time ends, explode quickly
                    if (!piecesInWitchTime && death.timer > 20) {
                        spawnParticles(death.x, death.y, death.color, 4, 2);
                        return false;
                    }
                }
                return true;
            });

            if (game.hitFreeze > 0) { game.hitFreeze -= 1; return; }

            const player = game.player;

            // Update slot machine
            updateSlotMachine(1);

            // Handle slot machine input - Dash (O/L1) to select after 1 second
            if (slotMachine.active && slotMachine.spinning) {
                const canSelect = slotMachine.spinTimer >= 60; // Can select after 1 second
                const dashPressed = (gamepad && buttonJustPressed(gamepad.buttons, 4)) || keysJustPressed['KeyO'];
                if (canSelect && dashPressed) {
                    stopSlotMachine();
                }
            }

            // Auto weapon switch after 10 seconds if no enemies nearby
            if (!slotMachine.active && !game.witchTime.active) {
                // Check for nearby enemies
                let hasNearbyEnemy = false;
                const px = player.x, py = player.y;
                for (const enemy of game.enemies) {
                    if (enemy.health <= 0 || enemy.dead) continue;
                    const dx = enemy.x - px;
                    const dy = enemy.y - py;
                    if (dx * dx + dy * dy < WEAPON_SWITCH_ENEMY_RANGE * WEAPON_SWITCH_ENEMY_RANGE) {
                        hasNearbyEnemy = true;
                        break;
                    }
                }

                if (hasNearbyEnemy) {
                    weaponSwitchTimer = 0; // Reset timer when enemies are nearby
                } else {
                    weaponSwitchTimer++;
                    if (weaponSwitchTimer >= WEAPON_AUTO_SWITCH_TIME) {
                        cycleWeapon();
                        weaponSwitchTimer = 0;
                    }
                }
            }

            // Update player parry indicator - directional wedge pointing at first attackable enemy
            const parryableEnemy = findFirstParryableEnemy();
            if (parryableEnemy && !player.isParrying) {
                const attackConfig = parryableEnemy.type === ENEMY_BOSS ? bossAttack : enemyAttack;
                const chargePercent = parryableEnemy.chargeTime / attackConfig.chargeTime;
                const blinkPercent = attackConfig.blinkTime / attackConfig.chargeTime;
                const angleToEnemy = Math.atan2(parryableEnemy.y - player.y, parryableEnemy.x - player.x);
                const timeSinceBlink = parryableEnemy.chargeTime - attackConfig.blinkTime;
                const isBlinking = parryableEnemy.hasBlinked && timeSinceBlink < attackConfig.blinkDuration;
                
                player.parryIndicator = {
                    chargePercent,
                    blinkPercent,
                    hasBlinked: parryableEnemy.hasBlinked,
                    inParryWindow: parryableEnemy.inParryWindow,
                    angleToEnemy,
                    isBlinking
                };
            } else {
                player.parryIndicator = null;
            }

            game.bossSpawnTimer -= enemyTime;
            if (game.bossSpawnTimer <= 0) {
                spawnBoss();
                game.bossSpawnTimer = game.bossSpawnInterval;
            }

            if (player.hurtTimer > 0) player.hurtTimer -= playerTime;
            if (player.hurtTimer <= 0) player.isHurt = false;
            if (player.cantAttackTimer > 0) player.cantAttackTimer -= playerTime;
            if (player.movementPause > 0) player.movementPause -= playerTime;

            // HP regeneration system
            player.lastDamageTime += playerTime;
            if (player.lastDamageTime >= player.regenDelay && player.health < player.maxHealth) {
                player.health = Math.min(player.maxHealth, player.health + player.regenRate * playerTime);
            }
            
            if (player.isKnockedBack) {
                player.knockbackTimer -= playerTime;
                player.vx *= 0.95;
                player.vy *= 0.95;
                if (player.knockbackTimer <= 0) {
                    player.isKnockedBack = false;
                    player.isGrounded = true;
                    player.groundedTimer = bossAttack.groundedDuration;
                    player.vx = 0;
                    player.vy = 0;
                    spawnDust(player.x, player.y, 0);
                    game.screenShake = 8;
                }
            }
            
            if (player.isGrounded) {
                player.groundedTimer -= playerTime;
                if (player.groundedTimer <= 0) player.isGrounded = false;
            }

            // Movement input - gamepad or keyboard
            let moveX = 0, moveY = 0;
            if (gamepad) {
                moveX = Math.abs(gamepad.axes[0]) > 0.15 ? gamepad.axes[0] : 0;
                moveY = Math.abs(gamepad.axes[1]) > 0.15 ? gamepad.axes[1] : 0;
            }
            // Keyboard WASD overrides if pressed
            let kbX = 0, kbY = 0;
            if (keys['KeyW'] || keys['ArrowUp']) kbY -= 1;
            if (keys['KeyS'] || keys['ArrowDown']) kbY += 1;
            if (keys['KeyA'] || keys['ArrowLeft']) kbX -= 1;
            if (keys['KeyD'] || keys['ArrowRight']) kbX += 1;
            if (kbX !== 0 || kbY !== 0) {
                // Normalize diagonal
                const len = Math.sqrt(kbX * kbX + kbY * kbY);
                moveX = kbX / len;
                moveY = kbY / len;
            }
            game.hasMoveInput = Math.abs(moveX) > 0.1 || Math.abs(moveY) > 0.1;
            if (game.hasMoveInput) game.currentMoveAngle = Math.atan2(moveY, moveX);

            if (player.dashCooldown > 0 && !player.isDashing) player.dashCooldown -= playerTime;
            if (player.meleeCooldown > 0) player.meleeCooldown -= playerTime;
            if (player.meleeFrame > 0) player.meleeFrame -= playerTime;

            // Combo reset timer - reset combo count if no attack within time window
            if (player.comboResetTimer > 0) {
                player.comboResetTimer -= playerTime;
                if (player.comboResetTimer <= 0) {
                    player.meleeComboCount = 0;
                }
            }

            const chargeVisualDelay = 10;
            if (player.isChargingMelee && !player.isParrying) {
                player.meleeChargeTime += playerTime;
                if (player.meleeChargeTime >= player.meleeChargeMax && !player.chargeReady) {
                    player.chargeReady = true;
                    spawnShockwave(player.x, player.y, '#ff00ff', 80);
                    spawnParticles(player.x, player.y, '#ff00ff', 20, 8);
                    game.screenShake = 6;
                }
                if (player.meleeChargeTime > chargeVisualDelay && Math.floor(player.meleeChargeTime) % 4 === 0) {
                    const chargePercent = Math.min(1, (player.meleeChargeTime - chargeVisualDelay) / (player.meleeChargeMax - chargeVisualDelay));
                    const angle = Math.random() * Math.PI * 2;
                    const dist = 30 + Math.random() * 20;
                    game.chargeParticles.push({
                        x: player.x + Math.cos(angle) * dist, y: player.y + Math.sin(angle) * dist,
                        life: 20, maxLife: 20, radius: 2 + chargePercent * 4,
                        color: chargePercent >= 1 ? '#ff00ff' : '#ffaaff'
                    });
                }
            }

            if (player.isKnockedBack || player.isGrounded) {
                // No control
            } else if (player.isDashing) {
                player.dashDuration -= playerTime;
                // More ghost trails during witch time
                if (inWitchTime || Math.floor(player.dashDuration) % 2 === 0) addGhostTrail();
                if (game.hasMoveInput) {
                    let angleDiff = game.currentMoveAngle - player.dashAngle;
                    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                    player.dashAngle += angleDiff * 0.08 * playerTime;
                    const currentSpeed = Math.sqrt(player.vx * player.vx + player.vy * player.vy);
                    player.vx = Math.cos(player.dashAngle) * currentSpeed;
                    player.vy = Math.sin(player.dashAngle) * currentSpeed;
                }
                player.vx *= 0.92;
                player.vy *= 0.92;
                if (player.dashDuration <= 0) {
                    player.isDashing = false;
                    player.postDashWindow = 15; // Post-dash thrust window
                }
            } else if (player.movementPause <= 0) {
                const speedMult = player.isHurt ? player.hurtSlowdown : 1;
                // Collision slowdown
                const collisionMult = player.collisionSlowdown > 0 ? 0.4 : 1;
                const targetVx = moveX * player.speed * speedMult * collisionMult;
                const targetVy = moveY * player.speed * speedMult * collisionMult;
                player.vx += (targetVx - player.vx) * 0.3;
                player.vy += (targetVy - player.vy) * 0.3;
            } else {
                player.vx *= 0.8;
                player.vy *= 0.8;
            }
            
            // Update post-dash window and collision slowdown
            if (player.postDashWindow > 0) player.postDashWindow -= playerTime;
            if (player.collisionSlowdown > 0) player.collisionSlowdown -= playerTime;

            player.x += player.vx * playerTime;
            player.y += player.vy * playerTime;
            // Clamp player to game area bounds
            player.x = Math.max(player.radius, Math.min(GAME_AREA_WIDTH - player.radius, player.x));
            player.y = Math.max(player.radius, Math.min(GAME_AREA_HEIGHT - player.radius, player.y));


            // Full autoaim
            updateAutoAim();
            
            // Weapon cycle is now automatic (no manual control)

            // Auto-fire (always shooting)
            if (!slotMachine.active) shoot();

            // Melee: R1 (gamepad) or K (keyboard) - only charge attacks, no thrusts
            const r1Pressed = (gamepad && gamepad.buttons[5]?.pressed) || keys['KeyK'];
            const r1JustReleased = (gamepad && buttonJustReleased(gamepad.buttons, 5)) || keysJustReleased['KeyK'];

            if (player.cantAttackTimer <= 0 && !player.isParrying && !player.isKnockedBack && !player.isGrounded) {
                if (r1Pressed && !player.isDashing) {
                    startChargingMelee();
                }
            }
            if (r1JustReleased) releaseMelee();

            // Dash: L1 (gamepad) or O (keyboard)
            if ((gamepad && buttonJustPressed(gamepad.buttons, 4)) || keysJustPressed['KeyO']) dash();

            // Manual Witch Time activation: L2 or R2 (gamepad) or P (keyboard) when bar is full
            // Only if not in slot machine and witch time is ready
            if (!slotMachine.active && game.witchTimeCharge.ready && !game.witchTime.active) {
                const l2JustPressed = gamepad && buttonJustPressed(gamepad.buttons, 6);
                const r2JustPressed = gamepad && buttonJustPressed(gamepad.buttons, 7);
                if (l2JustPressed || r2JustPressed || keysJustPressed['KeyP']) {
                    activateWitchTimeManual();
                }
            }

            game.enemies.forEach(enemy => {
                if (enemy.dead) {
                    // Don't respawn during witch time (makes perfect clear easier)
                    if (!inWitchTime) {
                        enemy.respawnTimer -= enemyTime;
                        if (enemy.respawnTimer <= 0) {
                            if (enemy.type === ENEMY_BOSS) {
                                const idx = game.enemies.indexOf(enemy);
                                if (idx > -1) game.enemies.splice(idx, 1);
                                return;
                            }
                            const newEnemy = spawnEnemyFromEdge(enemy.type);
                            Object.assign(enemy, newEnemy);
                            enemy.dead = false;
                        }
                    }
                    return;
                }

                if (enemy.health <= 0) return;

                if (enemy.isStunned) {
                    enemy.stunTimer -= enemyTime;
                    if (enemy.stunTimer <= 0) enemy.isStunned = false;
                    if (enemy.hit > 0) enemy.hit -= enemyTime;
                    return;
                }

                if (enemy.attackPause > 0) {
                    enemy.attackPause -= enemyTime;
                    if (enemy.hit > 0) enemy.hit -= enemyTime;
                    return;
                }

                if (enemy.attackCooldown > 0) enemy.attackCooldown -= enemyTime;

                const dx = player.x - enemy.x;
                const dy = player.y - enemy.y;
                const distToPlayer = Math.sqrt(dx * dx + dy * dy);
                const angleToPlayer = Math.atan2(dy, dx);

                enemy.isAggro = distToPlayer < enemy.aggroRange;

                // Laser attack system (for ENEMY_BIG and ENEMY_BOSS)
                if (enemy.type === ENEMY_BIG || enemy.type === ENEMY_BOSS) {
                    updateEnemyLaser(enemy, distToPlayer, angleToPlayer, enemyTime);
                }

                if (enemy.isAggro || enemy.isCharging) {
                    let targetAngle = angleToPlayer;
                    let angleDiff = targetAngle - enemy.angle;
                    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                    enemy.angle += angleDiff * 0.1 * enemyTime;
                    
                    // Track time in attack range
                    if (distToPlayer < enemy.chargeRange) {
                        enemy.timeInAttackRange += enemyTime;
                    } else {
                        enemy.timeInAttackRange = 0;
                    }
                    
                    // Movement during attack charging - windup/lunge system
                    if (enemy.isCharging) {
                        const attackConfig = enemy.type === ENEMY_BOSS ? bossAttack : enemyAttack;
                        const chargePercent = enemy.chargeTime / attackConfig.chargeTime;
                        const windupTime = 0.4; // First 40% is windup (back up)
                        const lungeTime = 0.7;  // 40-70% is lunge (forward)
                        // 70-100% is attack

                        if (chargePercent < windupTime) {
                            // Windup: back away from player
                            const backSpeed = enemy.aggroSpeed * 1.5;
                            enemy.vx = -Math.cos(angleToPlayer) * backSpeed;
                            enemy.vy = -Math.sin(angleToPlayer) * backSpeed;
                        } else if (chargePercent < lungeTime) {
                            // Lunge: charge toward player
                            const lungeSpeed = enemy.aggroSpeed * 3;
                            enemy.vx = Math.cos(angleToPlayer) * lungeSpeed;
                            enemy.vy = Math.sin(angleToPlayer) * lungeSpeed;
                        } else {
                            // Attack wind-down: slow/stop
                            enemy.vx *= 0.8;
                            enemy.vy *= 0.8;
                        }
                    } else if (enemy.attackPause > 0) {
                        enemy.vx = 0;
                        enemy.vy = 0;
                    } else {
                        // Normal movement
                        if (distToPlayer < enemy.orbitRange) {
                            const orbitAngle = angleToPlayer + Math.PI / 2;
                            enemy.vx = Math.cos(orbitAngle) * enemy.aggroSpeed * 0.5;
                            enemy.vy = Math.sin(orbitAngle) * enemy.aggroSpeed * 0.5;
                        } else if (distToPlayer < enemy.aggroRange) {
                            enemy.vx = Math.cos(angleToPlayer) * enemy.aggroSpeed;
                            enemy.vy = Math.sin(angleToPlayer) * enemy.aggroSpeed;
                        } else {
                            enemy.vx *= 0.95;
                            enemy.vy *= 0.95;
                        }
                    }
                    
                    // Start charging attack only if:
                    // 1. Not already charging
                    // 2. Attack cooldown is done
                    // 3. In attack range
                    // 4. Have been in range for 1-2 seconds (60-120 frames)
                    // 5. NOT during witch time
                    const inWitchTime = game.witchTime.active && !game.witchTime.circleWipe;
                    const attackDelay = 60 + Math.random() * 60; // 1-2 seconds
                    
                    // Don't start melee attack if charging/firing laser
                    if (!enemy.isCharging &&
                        enemy.attackCooldown <= 0 &&
                        distToPlayer < enemy.chargeRange &&
                        enemy.timeInAttackRange >= attackDelay &&
                        !inWitchTime &&
                        !enemy.laserCharging && !enemy.laserFiring) {
                        enemy.isCharging = true;
                        enemy.chargeTime = 0;
                        enemy.inParryWindow = false;
                        enemy.hasBlinked = false;
                    }
                    
                    // Cancel charging if witch time activates
                    if (enemy.isCharging && inWitchTime) {
                        enemy.isCharging = false;
                        enemy.chargeTime = 0;
                        enemy.inParryWindow = false;
                        enemy.hasBlinked = false;
                        enemy.timeInAttackRange = 0;
                    }
                    
                    if (enemy.isCharging) {
                        enemy.chargeTime += enemyTime;
                        const attackConfig = enemy.type === ENEMY_BOSS ? bossAttack : enemyAttack;

                        // Can parry anytime during charge (not just after blink)
                        enemy.inParryWindow = true;

                        // Track blink for visual effect only
                        if (enemy.chargeTime >= attackConfig.blinkTime && !enemy.hasBlinked) {
                            enemy.hasBlinked = true;
                        }

                        if (enemy.chargeTime >= attackConfig.chargeTime) {
                            enemyAttackPlayer(enemy);
                        }
                    }
                } else {
                    enemy.isCharging = false;
                    enemy.chargeTime = 0;
                    enemy.inParryWindow = false;
                    enemy.hasBlinked = false;
                    enemy.timeInAttackRange = 0; // Reset timer when not aggro
                    
                    enemy.moveTimer -= enemyTime;
                    if (enemy.moveTimer <= 0) {
                        const newAngle = Math.random() * Math.PI * 2;
                        enemy.vx = Math.cos(newAngle) * enemy.baseSpeed;
                        enemy.vy = Math.sin(newAngle) * enemy.baseSpeed;
                        enemy.angle = newAngle;
                        enemy.moveTimer = 90 + Math.random() * 150;
                    }
                }

                enemy.x += enemy.vx * enemyTime;
                enemy.y += enemy.vy * enemyTime;

                // Clamp enemies to game area bounds
                const boundSize = enemy.size / 2;
                if (enemy.x < boundSize || enemy.x > GAME_AREA_WIDTH - boundSize) {
                    enemy.vx *= -1;
                    enemy.x = Math.max(boundSize, Math.min(GAME_AREA_WIDTH - boundSize, enemy.x));
                }
                if (enemy.y < boundSize || enemy.y > GAME_AREA_HEIGHT - boundSize) {
                    enemy.vy *= -1;
                    enemy.y = Math.max(boundSize, Math.min(GAME_AREA_HEIGHT - boundSize, enemy.y));
                }

                if (enemy.hit > 0) enemy.hit -= enemyTime;
                // Decay hit bounce animation (slower for more visible effect)
                if (enemy.hitBounce > 0) enemy.hitBounce -= 0.04;
                // Update spawn fade-in
                if (enemy.spawnFadeIn > 0) {
                    enemy.spawnFadeIn -= 1 / enemy.spawnFadeDuration;
                    if (enemy.spawnFadeIn < 0) enemy.spawnFadeIn = 0;
                }
            });
            
            // Enemy-enemy collision
            for (let i = 0; i < game.enemies.length; i++) {
                const e1 = game.enemies[i];
                if (e1.dead || e1.health <= 0) continue;
                
                for (let j = i + 1; j < game.enemies.length; j++) {
                    const e2 = game.enemies[j];
                    if (e2.dead || e2.health <= 0) continue;
                    
                    const dx = e2.x - e1.x;
                    const dy = e2.y - e1.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const minDist = (e1.size + e2.size) / 2;
                    
                    if (dist < minDist && dist > 0) {
                        const overlap = minDist - dist;
                        const nx = dx / dist;
                        const ny = dy / dist;
                        e1.x -= nx * overlap * 0.5;
                        e1.y -= ny * overlap * 0.5;
                        e2.x += nx * overlap * 0.5;
                        e2.y += ny * overlap * 0.5;
                        e1.vx -= nx * 0.3;
                        e1.vy -= ny * 0.3;
                        e2.vx += nx * 0.3;
                        e2.vy += ny * 0.3;
                    }
                }
                
                // Enemy-player collision
                if (!player.isDashing && !player.isKnockedBack) {
                    const dx = player.x - e1.x;
                    const dy = player.y - e1.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const minDist = player.radius + e1.size / 2;
                    
                    if (dist < minDist && dist > 0) {
                        const overlap = minDist - dist;
                        const nx = dx / dist;
                        const ny = dy / dist;
                        player.x += nx * overlap;
                        player.y += ny * overlap;
                        player.collisionSlowdown = 8;
                    }
                }
            }

            game.bullets = game.bullets.filter(bullet => {
                bullet.x += bullet.vx;
                bullet.y += bullet.vy;
                bullet.life -= 1;
                for (let enemy of game.enemies) {
                    if (enemy.health <= 0 || enemy.dead) continue;
                    const dx = bullet.x - enemy.x;
                    const dy = bullet.y - enemy.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < enemy.size / 2 + 4) {
                        // x2 damage during witch time
                        const inWitchTime = game.witchTime.active && !game.witchTime.circleWipe;
                        const finalDamage = inWitchTime ? bullet.damage * 2 : bullet.damage;
                        enemy.health -= finalDamage;
                        enemy.hit = 10;
                        enemy.hitBounce = 0.5;  // Smaller bounce for gun hits
                        enemy.hitBounceType = 'gun';
                        stunEnemy(enemy);
                        game.screenShake = 4;
                        enemy.x += Math.cos(bullet.angle) * 5;
                        enemy.y += Math.sin(bullet.angle) * 5;
                        spawnParticles(bullet.x, bullet.y, enemy.color, 8);
                        // Bullets don't charge witch time - only melee attacks do
                        if (enemy.health <= 0) killEnemy(enemy, game.player.x, game.player.y, false);
                        return false;
                    }
                }
                // Remove bullets outside game area (with margin)
                if (bullet.x < -50 || bullet.x > GAME_AREA_WIDTH + 50 || bullet.y < -50 || bullet.y > GAME_AREA_HEIGHT + 50) return false;
                return bullet.life > 0;
            });

            game.particles = game.particles.filter(p => {
                p.x += p.vx; p.y += p.vy;
                p.vx *= 0.95; p.vy *= 0.95; p.life -= 1;
                return p.life > 0;
            });
            // Hard limit particles
            while (game.particles.length > 150) game.particles.shift();
            
            game.dustParticles = game.dustParticles.filter(p => {
                p.x += p.vx; p.y += p.vy;
                p.vx *= 0.9; p.vy *= 0.9; p.life -= 1;
                return p.life > 0;
            });
            while (game.dustParticles.length > 50) game.dustParticles.shift();
            
            game.chargeParticles = game.chargeParticles.filter(p => {
                const dx = player.x - p.x; const dy = player.y - p.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > 2) { p.x += (dx / dist) * 4; p.y += (dy / dist) * 4; }
                p.life -= 1;
                return p.life > 0;
            });
            game.ghostTrails = game.ghostTrails.filter(g => { g.life -= 1; return g.life > 0; });
            game.slashEffects = game.slashEffects.filter(s => {
                if (s.trackPlayer) { s.x = player.x; s.y = player.y; }
                s.life -= 1;
                return s.life > 0;
            });
        }

        function drawCircle(x, y, radius, color) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawDiamond(x, y, size, angle, color) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle + Math.PI / 4);
            ctx.fillStyle = color;
            ctx.fillRect(-size/2, -size/2, size, size);
            ctx.restore();
        }

        function drawPentagon(x, y, size, angle, color) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle - Math.PI / 2);
            ctx.fillStyle = color;
            ctx.beginPath();
            for (let i = 0; i < 5; i++) {
                const a = (i / 5) * Math.PI * 2;
                const px = Math.cos(a) * size * 0.55;
                const py = Math.sin(a) * size * 0.55;
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }

        function drawHalfShape(x, y, size, type, cutAngle, side, color) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(cutAngle);
            ctx.beginPath();
            ctx.rect(-size, side > 0 ? 0 : -size, size * 2, size);
            ctx.clip();
            ctx.rotate(-cutAngle);
            ctx.fillStyle = color;
            
            if (type === ENEMY_NORMAL) {
                ctx.beginPath();
                ctx.arc(0, 0, size / 2, 0, Math.PI * 2);
                ctx.fill();
            } else if (type === ENEMY_BIG) {
                ctx.save();
                ctx.rotate(Math.PI / 4);
                ctx.fillRect(-size/2, -size/2, size, size);
                ctx.restore();
            } else if (type === ENEMY_BOSS) {
                ctx.beginPath();
                for (let i = 0; i < 5; i++) {
                    const a = (i / 5) * Math.PI * 2 - Math.PI / 2;
                    const px = Math.cos(a) * size * 0.55;
                    const py = Math.sin(a) * size * 0.55;
                    if (i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.closePath();
                ctx.fill();
            }
            ctx.restore();
        }

        function drawPlayer(x, y, radius, angle, color, isCharging, chargePercent, isHurt, isGrounded, witchTimeReady) {
            // If player is dead and in cut phase, draw 4 pieces separating
            if (game.death && game.death.active && game.death.phase <= 1) {
                const death = game.death;
                const separationSpeed = 1.2;
                const separation = Math.min(death.timer * separationSpeed, 40);
                const cutAngle1 = death.cutAngle;
                const cutAngle2 = cutAngle1 + Math.PI * 0.5; // Second cut perpendicular

                // Show second cut after cutPhase changes
                const hasSecondCut = death.cutPhase >= 1;

                // Calculate separation directions for both cuts
                const sep1X = Math.cos(cutAngle1 + Math.PI/2) * separation;
                const sep1Y = Math.sin(cutAngle1 + Math.PI/2) * separation;
                const sep2X = Math.cos(cutAngle2 + Math.PI/2) * separation * (hasSecondCut ? 0.7 : 0);
                const sep2Y = Math.sin(cutAngle2 + Math.PI/2) * separation * (hasSecondCut ? 0.7 : 0);

                // Draw 4 pieces (or 2 if second cut not yet done)
                const pieces = hasSecondCut ? 4 : 2;
                for (let piece = 0; piece < pieces; piece++) {
                    ctx.save();

                    // Calculate offset for each piece
                    let offsetX = 0, offsetY = 0, rotOffset = 0;
                    if (pieces === 2) {
                        // 2 halves from first cut
                        const sign = piece === 0 ? 1 : -1;
                        offsetX = sep1X * sign * 0.5;
                        offsetY = sep1Y * sign * 0.5;
                        rotOffset = sign * 0.15 * (separation / 40);
                    } else {
                        // 4 quarters from both cuts
                        const sign1 = (piece % 2 === 0) ? 1 : -1;
                        const sign2 = (piece < 2) ? 1 : -1;
                        offsetX = sep1X * sign1 * 0.4 + sep2X * sign2 * 0.4;
                        offsetY = sep1Y * sign1 * 0.4 + sep2Y * sign2 * 0.4;
                        rotOffset = (sign1 * 0.12 + sign2 * 0.08) * (separation / 40);
                    }

                    ctx.translate(x + offsetX, y + offsetY);
                    ctx.rotate(angle + rotOffset);

                    // Clip to the appropriate section
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    const clipAngle = cutAngle1 - angle;
                    if (pieces === 2) {
                        // Half
                        if (piece === 0) {
                            ctx.arc(0, 0, radius * 2, clipAngle, clipAngle + Math.PI);
                        } else {
                            ctx.arc(0, 0, radius * 2, clipAngle + Math.PI, clipAngle + Math.PI * 2);
                        }
                    } else {
                        // Quarter
                        const startAngles = [0, Math.PI, Math.PI * 0.5, Math.PI * 1.5];
                        const quarterAngle = clipAngle + startAngles[piece];
                        ctx.arc(0, 0, radius * 2, quarterAngle, quarterAngle + Math.PI * 0.5);
                    }
                    ctx.closePath();
                    ctx.clip();

                    // Draw player shape (blink between red and white)
                    const blinkPhase = Math.floor(Date.now() / 80) % 2;
                    ctx.fillStyle = blinkPhase ? '#ff6666' : '#ffffff';
                    ctx.beginPath();
                    ctx.moveTo(radius * 1.3, 0);
                    ctx.arc(0, 0, radius, -Math.PI * 0.25, Math.PI * 0.25, true);
                    ctx.closePath();
                    ctx.fill();

                    ctx.restore();
                }
                return;
            }

            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle);
            if (isCharging && chargePercent > 0) {
                ctx.globalAlpha = 0.3 + chargePercent * 0.4;
                ctx.fillStyle = chargePercent >= 1 ? '#ff00ff' : '#ffaaff';
                ctx.beginPath();
                ctx.arc(0, 0, radius * (1.5 + chargePercent * 0.5), 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }

            // Determine player color
            let playerColor;
            if (isGrounded) {
                playerColor = '#888888';
            } else if (isHurt) {
                playerColor = '#ff6666';
            } else if (witchTimeReady) {
                // Blink magenta/white when witch time is ready (unified with bar)
                const blinkPhase = Math.floor(Date.now() / 100) % 2; // 10 fps blink
                playerColor = blinkPhase === 0 ? '#ff00ff' : '#ffffff';
            } else {
                playerColor = color;
            }

            ctx.fillStyle = playerColor;
            ctx.beginPath();
            ctx.moveTo(radius * 1.3, 0);
            ctx.arc(0, 0, radius, -Math.PI * 0.25, Math.PI * 0.25, true);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }

        function drawGhostShape(x, y, radius, angle, alpha) {
            ctx.save();
            ctx.globalAlpha = alpha;
            ctx.translate(x, y);
            ctx.rotate(angle);
            ctx.fillStyle = '#4ecca3';
            ctx.beginPath();
            ctx.moveTo(radius * 1.3, 0);
            ctx.arc(0, 0, radius, -Math.PI * 0.25, Math.PI * 0.25, true);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
            ctx.globalAlpha = 1;
        }

        function render() {
            const player = game.player;

            // Calculate camera offset for world-to-screen transformation
            ctx.save();

            if (game.screenShake > 0.5) {
                ctx.translate((Math.random() - 0.5) * game.screenShake * 2, (Math.random() - 0.5) * game.screenShake * 2);
            }

            // Fill entire viewport with outside color
            ctx.fillStyle = OUTSIDE_AREA_COLOR;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Apply camera transformation for world space rendering (with zoom)
            ctx.save();
            // Translate to center, apply zoom, then offset by camera position
            ctx.translate(VIEWPORT_WIDTH / 2, VIEWPORT_HEIGHT / 2);
            ctx.scale(camera.zoom, camera.zoom);
            ctx.translate(-camera.x, -camera.y);

            // Draw game area background
            ctx.fillStyle = GAME_AREA_COLOR;
            ctx.fillRect(0, 0, GAME_AREA_WIDTH, GAME_AREA_HEIGHT);

            // Grid lines (drawn BEFORE border so border appears on top)
            ctx.strokeStyle = '#1a2744';
            ctx.lineWidth = 1;
            for (let x = 0; x < GAME_AREA_WIDTH; x += 50) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, GAME_AREA_HEIGHT); ctx.stroke(); }
            for (let y = 0; y < GAME_AREA_HEIGHT; y += 50) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(GAME_AREA_WIDTH, y); ctx.stroke(); }

            // Draw game area border (on top of grid, compensate thickness for zoom)
            ctx.strokeStyle = GAME_AREA_BORDER_COLOR;
            ctx.lineWidth = 3 / camera.zoom;
            ctx.strokeRect(0, 0, GAME_AREA_WIDTH, GAME_AREA_HEIGHT);

            game.shockwaves.forEach(sw => {
                ctx.strokeStyle = sw.color;
                ctx.lineWidth = 2;
                ctx.globalAlpha = (sw.life / sw.maxLife) * 0.8;
                ctx.beginPath();
                ctx.arc(sw.x, sw.y, sw.radius, 0, Math.PI * 2);
                ctx.stroke();
            });
            ctx.globalAlpha = 1;

            game.dustParticles.forEach(p => {
                ctx.globalAlpha = (p.life / p.maxLife) * 0.5;
                ctx.fillStyle = '#8b7355';
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.radius * (p.life / p.maxLife), 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;

            game.chargeParticles.forEach(p => {
                ctx.globalAlpha = p.life / p.maxLife;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;

            game.ghostTrails.forEach(ghost => {
                drawGhostShape(ghost.x, ghost.y, ghost.radius, ghost.angle, (ghost.life / ghost.maxLife) * 0.5);
            });

            game.particles.forEach(p => {
                ctx.globalAlpha = p.life / p.maxLife;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.radius * (p.life / p.maxLife), 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;

            game.slashEffects.forEach(slash => {
                const progress = 1 - (slash.life / slash.maxLife);
                ctx.save();
                ctx.translate(slash.x, slash.y);
                ctx.rotate(slash.angle);
                ctx.globalAlpha = (slash.life / slash.maxLife) * 0.9;
                if (slash.type === 'arc') {
                    // Thicker line for charged attacks
                    const baseWidth = slash.isCharged ? 6 : 4;
                    ctx.strokeStyle = slash.color;
                    ctx.lineWidth = baseWidth + (1 - progress) * baseWidth;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.arc(0, 0, slash.range * (0.5 + progress * 0.5), -slash.arc / 2 + progress * 0.5, slash.arc / 2 - progress * 0.5);
                    ctx.stroke();
                } else if (slash.type === 'thrust') {
                    const len = slash.length * (0.5 + progress * 0.5);
                    const w = slash.width * (1 - progress * 0.3);
                    const offset = slash.offset || 0;
                    const tipLen = 25;
                    const backTipLen = 12; // Pointed back (shorter than front)
                    
                    // Trail effect (draw multiple times with increasing alpha)
                    for (let t = 0; t < 3; t++) {
                        const trailOffset = t * 8;
                        const trailAlpha = (1 - t * 0.3) * (slash.life / slash.maxLife);
                        ctx.globalAlpha = trailAlpha * 0.7;
                        ctx.fillStyle = slash.color;
                        ctx.beginPath();
                        // Front point
                        ctx.moveTo(offset + len + tipLen - trailOffset, 0);
                        // Top edge
                        ctx.lineTo(offset + len - trailOffset, -w/4);
                        ctx.lineTo(offset - trailOffset, -w/2);
                        // Back point (pointed, not flat)
                        ctx.lineTo(offset - backTipLen - trailOffset, 0);
                        // Bottom edge
                        ctx.lineTo(offset - trailOffset, w/2);
                        ctx.lineTo(offset + len - trailOffset, w/4);
                        ctx.closePath();
                        ctx.fill();
                    }
                    ctx.globalAlpha = (slash.life / slash.maxLife) * 0.9;
                }
                ctx.restore();
            });
            ctx.globalAlpha = 1;

            game.slashDeaths.forEach(death => {
                if (death.phase === 'line') {
                    // Longer slash line with fade at tips
                    const lineLen = death.size * 1.8;
                    const alpha = 1 - (death.timer / 20);
                    const x1 = death.x + Math.cos(death.slashAngle) * lineLen;
                    const y1 = death.y + Math.sin(death.slashAngle) * lineLen;
                    const x2 = death.x - Math.cos(death.slashAngle) * lineLen;
                    const y2 = death.y - Math.sin(death.slashAngle) * lineLen;
                    
                    const gradient = ctx.createLinearGradient(x1, y1, x2, y2);
                    gradient.addColorStop(0, `rgba(255,255,255,0)`);
                    gradient.addColorStop(0.2, `rgba(255,255,255,${alpha})`);
                    gradient.addColorStop(0.8, `rgba(255,255,255,${alpha})`);
                    gradient.addColorStop(1, `rgba(255,255,255,0)`);
                    
                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = 3;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                } else if (death.phase === 'flash') {
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(death.x, death.y, death.size * 0.7, 0, Math.PI * 2);
                    ctx.fill();
                } else if (death.phase === 'split') {
                    const perpAngle = death.slashAngle + Math.PI / 2;
                    const sep = death.separation;
                    // Pieces slightly darker than live enemies but still visible
                    ctx.globalAlpha = 0.7;
                    drawHalfShape(death.x + Math.cos(perpAngle) * sep, death.y + Math.sin(perpAngle) * sep,
                        death.size, death.type, death.slashAngle, 1, death.color);
                    drawHalfShape(death.x - Math.cos(perpAngle) * sep, death.y - Math.sin(perpAngle) * sep,
                        death.size, death.type, death.slashAngle, -1, death.color);
                    ctx.globalAlpha = 1;
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.globalAlpha = 0.8;
                    ctx.beginPath();
                    ctx.moveTo(death.x + Math.cos(death.slashAngle) * death.size, death.y + Math.sin(death.slashAngle) * death.size);
                    ctx.lineTo(death.x - Math.cos(death.slashAngle) * death.size, death.y - Math.sin(death.slashAngle) * death.size);
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                } else if (death.phase === 'suspended') {
                    // Suspended pieces during witch time - same draw as split but static
                    const perpAngle = death.slashAngle + Math.PI / 2;
                    const sep = death.finalSep || death.separation;
                    // Pieces slightly darker than live enemies but still visible
                    ctx.globalAlpha = 0.7;
                    drawHalfShape(death.x + Math.cos(perpAngle) * sep, death.y + Math.sin(perpAngle) * sep,
                        death.size, death.type, death.slashAngle, 1, death.color);
                    drawHalfShape(death.x - Math.cos(perpAngle) * sep, death.y - Math.sin(perpAngle) * sep,
                        death.size, death.type, death.slashAngle, -1, death.color);
                    ctx.globalAlpha = 1;
                } else if (death.phase === 'piece' || death.phase === 'half' || death.phase === 'quarter') {
                    // Individual piece (a single half or quarter) - draw using drawHalfShape
                    const side = death.cutSide || 1;
                    // Quarters darker than halves to show they're smaller pieces
                    const isQuarter = death.phase === 'quarter' || death.size < 25;
                    ctx.globalAlpha = isQuarter ? 0.55 : 0.7;
                    drawHalfShape(death.x, death.y, death.size, death.type, death.slashAngle, side, death.color);
                    ctx.globalAlpha = 1;
                }
            });

            // Enemy pieces (during witch time)
            enemyPieces.forEach(piece => {
                if (piece.health <= 0) return;
                const drawColor = piece.hit > 0 ? '#ffffff' : piece.color;
                
                // Draw as half shape based on cut
                if (piece.cutAngle !== undefined) {
                    drawHalfShape(piece.x, piece.y, piece.size, piece.type, piece.cutAngle, piece.side, drawColor);
                } else {
                    drawCircle(piece.x, piece.y, piece.size / 2, drawColor);
                }
            });

            // Draw bullets FIRST (underneath everything)
            game.bullets.forEach(bullet => {
                ctx.fillStyle = bullet.color;
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = bullet.color;
                ctx.globalAlpha = 0.5;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(bullet.x, bullet.y);
                ctx.lineTo(bullet.x - bullet.vx * 2, bullet.y - bullet.vy * 2);
                ctx.stroke();
                ctx.globalAlpha = 1;
            });

            // Draw lasers (underneath enemies)
            game.enemies.forEach(enemy => {
                if (enemy.health <= 0 || enemy.dead) return;
                if ((enemy.type === ENEMY_BIG || enemy.type === ENEMY_BOSS) && (enemy.laserCharging || enemy.laserFiring)) {
                    const config = getLaserConfig(enemy);
                    const chargePercent = enemy.laserChargeTime / config.chargeTime;
                    const isBoss = enemy.type === ENEMY_BOSS;

                    const laserLength = 1500;
                    const endX = enemy.x + Math.cos(enemy.laserAimAngle) * laserLength;
                    const endY = enemy.y + Math.sin(enemy.laserAimAngle) * laserLength;

                    // Set line caps for solid corners
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';

                    if (enemy.laserFiring) {
                        const blinkPhase = Math.floor(Date.now() / 50) % 2;
                        if (isBoss) {
                            // Outer glow - solid
                            ctx.strokeStyle = blinkPhase ? '#ffffff' : '#ffff88';
                            ctx.lineWidth = config.fireLineWidth + 15;
                            ctx.beginPath();
                            ctx.moveTo(enemy.x, enemy.y);
                            ctx.lineTo(endX, endY);
                            ctx.stroke();

                            // Middle layer - solid
                            ctx.strokeStyle = blinkPhase ? '#ffff00' : '#ffcc00';
                            ctx.lineWidth = config.fireLineWidth + 6;
                            ctx.beginPath();
                            ctx.moveTo(enemy.x, enemy.y);
                            ctx.lineTo(endX, endY);
                            ctx.stroke();

                            // Core - solid
                            ctx.strokeStyle = blinkPhase ? '#ffffff' : '#ffff00';
                            ctx.lineWidth = config.fireLineWidth;
                            ctx.beginPath();
                            ctx.moveTo(enemy.x, enemy.y);
                            ctx.lineTo(endX, endY);
                            ctx.stroke();
                        } else {
                            // Big enemy laser - solid
                            ctx.strokeStyle = blinkPhase ? '#ffffff' : '#88aaff';
                            ctx.lineWidth = config.fireLineWidth;
                            ctx.beginPath();
                            ctx.moveTo(enemy.x, enemy.y);
                            ctx.lineTo(endX, endY);
                            ctx.stroke();
                        }
                    } else {
                        // Charging - solid colors
                        if (isBoss) {
                            const blinkSpeed = 100 + (1 - chargePercent) * 200;
                            const blinkPhase = Math.sin(Date.now() / blinkSpeed * Math.PI);
                            const baseColor = chargePercent < 0.7 ? '#ffcc00' : '#ff3333';
                            ctx.strokeStyle = baseColor;
                            ctx.lineWidth = config.lineWidth + chargePercent * 4;
                            ctx.beginPath();
                            ctx.moveTo(enemy.x, enemy.y);
                            ctx.lineTo(endX, endY);
                            ctx.stroke();

                            if (Math.random() < 0.3 + chargePercent * 0.5) {
                                const particleDist = 100 + Math.random() * 200;
                                const particleAngle = enemy.laserAimAngle + (Math.random() - 0.5) * 0.8;
                                const px = enemy.x + Math.cos(particleAngle) * particleDist;
                                const py = enemy.y + Math.sin(particleAngle) * particleDist;
                                game.particles.push({
                                    x: px, y: py,
                                    vx: (enemy.x - px) * 0.08,
                                    vy: (enemy.y - py) * 0.08,
                                    life: 15 + Math.random() * 10,
                                    maxLife: 25,
                                    radius: 2 + Math.random() * 2,
                                    color: chargePercent < 0.7 ? '#ffcc00' : '#ff6644'
                                });
                            }
                        } else {
                            ctx.strokeStyle = chargePercent < 0.7 ? '#6688ff' : '#ff6688';
                            ctx.lineWidth = config.lineWidth + chargePercent * 2;
                            ctx.beginPath();
                            ctx.moveTo(enemy.x, enemy.y);
                            ctx.lineTo(endX, endY);
                            ctx.stroke();
                        }
                    }

                    // Reset line caps
                    ctx.lineCap = 'butt';
                    ctx.lineJoin = 'miter';
                }
            });

            // Draw laser deflect visual BEFORE enemies (underneath them)
            if (game.laserDeflect && game.laserDeflect.timer > 0) {
                const deflect = game.laserDeflect;
                const blinkPhase = Math.floor(Date.now() / 50) % 2;

                // Colors based on enemy type (boss = yellow, big = blue)
                const baseColor = deflect.isBoss ? '#ffff00' : '#88aaff';
                const blinkColor = blinkPhase ? '#ffffff' : baseColor;
                const lineWidth = deflect.isBoss ? 20 : 12;

                // Set line caps for solid corners at join point
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                if (deflect.isBoss) {
                    // Boss: outer glow - draw as single path for seamless join
                    ctx.strokeStyle = blinkPhase ? '#ffffff' : '#ffff88';
                    ctx.lineWidth = lineWidth + 10;
                    ctx.beginPath();
                    ctx.moveTo(deflect.fromX, deflect.fromY);
                    ctx.lineTo(deflect.bounceX, deflect.bounceY);
                    ctx.lineTo(deflect.toX, deflect.toY);
                    ctx.stroke();
                }

                // Main laser line - single path from enemy through player to target
                ctx.strokeStyle = blinkColor;
                ctx.lineWidth = lineWidth;
                ctx.beginPath();
                ctx.moveTo(deflect.fromX, deflect.fromY);
                ctx.lineTo(deflect.bounceX, deflect.bounceY);
                ctx.lineTo(deflect.toX, deflect.toY);
                ctx.stroke();

                // Draw a circle at the bounce point to fill any remaining gap
                ctx.fillStyle = blinkColor;
                ctx.beginPath();
                ctx.arc(deflect.bounceX, deflect.bounceY, lineWidth / 2, 0, Math.PI * 2);
                ctx.fill();

                // Reset line caps
                ctx.lineCap = 'butt';
                ctx.lineJoin = 'miter';

                deflect.timer--;
            }

            // Enemies - draw all charging rings (not affected by parry state)
            game.enemies.forEach(enemy => {
                if (enemy.health <= 0 || enemy.dead) return;

                // Don't show melee attack ring if enemy is charging/firing laser
                if (enemy.isCharging && !enemy.laserCharging && !enemy.laserFiring) {
                    const attackConfig = enemy.type === ENEMY_BOSS ? bossAttack : enemyAttack;
                    const chargePercent = enemy.chargeTime / attackConfig.chargeTime;
                    const maxBorderDist = 25;
                    const borderDist = maxBorderDist - (chargePercent * maxBorderDist);

                    // Yellow for 90% of charge, red only at the end as emphasis
                    let borderColor;
                    if (enemy.chargeTime < attackConfig.blinkTime) {
                        borderColor = '#ffcc00'; // Yellow during most of charge
                    } else {
                        borderColor = '#ff3333'; // Red only at the end
                    }

                    ctx.strokeStyle = borderColor;
                    ctx.lineWidth = 2;
                    ctx.globalAlpha = 0.6 + chargePercent * 0.3;

                    const size = enemy.size / 2 + borderDist;
                    ctx.beginPath();
                    ctx.arc(enemy.x, enemy.y, size, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                }
                
                if (enemy.isStunned) {
                    for (let i = 0; i < 3; i++) {
                        const starAngle = (Date.now() / 200 + i * Math.PI * 2 / 3) % (Math.PI * 2);
                        const starX = enemy.x + Math.cos(starAngle) * (enemy.size / 2 + 10);
                        const starY = enemy.y - enemy.size / 2 - 5 + Math.sin(starAngle * 2) * 3;
                        ctx.fillStyle = '#ffff00';
                        ctx.beginPath();
                        ctx.arc(starX, starY, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                const drawColor = enemy.hit > 0 ? '#ffffff' : enemy.color;

                // Apply hit bounce scale effect
                let bounceScale = 1;
                if (enemy.hitBounce > 0) {
                    // Melee: bigger squish (1.3x), Gun: smaller squish (1.15x)
                    const maxScale = enemy.hitBounceType === 'melee' ? 1.35 : 1.18;
                    // Bounce out then back: sin curve for smooth effect
                    bounceScale = 1 + (maxScale - 1) * Math.sin(enemy.hitBounce * Math.PI);
                }

                ctx.save();
                // Apply spawn fade-in opacity
                if (enemy.spawnFadeIn > 0) {
                    ctx.globalAlpha = 1 - enemy.spawnFadeIn;
                }
                ctx.translate(enemy.x, enemy.y);
                ctx.scale(bounceScale, bounceScale);
                ctx.translate(-enemy.x, -enemy.y);

                if (enemy.type === ENEMY_NORMAL) {
                    drawCircle(enemy.x, enemy.y, enemy.size / 2, drawColor);
                } else if (enemy.type === ENEMY_BIG) {
                    drawDiamond(enemy.x, enemy.y, enemy.size, enemy.angle, drawColor);
                } else if (enemy.type === ENEMY_BOSS) {
                    drawPentagon(enemy.x, enemy.y, enemy.size, enemy.angle, drawColor);
                }
                ctx.restore();
                ctx.globalAlpha = 1;
            });

            // Player
            if (player.isDashing) {
                ctx.globalAlpha = 0.4;
                ctx.fillStyle = player.isParrying ? (game.parryCircle?.color || '#aa66ff') : '#88ffcc';
                ctx.beginPath();
                ctx.arc(player.x, player.y, player.radius * 1.8, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }

            const chargeVisualDelay = 10;
            const showChargeVisual = player.isChargingMelee && player.meleeChargeTime > chargeVisualDelay;
            const visualChargePercent = showChargeVisual ? Math.min(1, (player.meleeChargeTime - chargeVisualDelay) / (player.meleeChargeMax - chargeVisualDelay)) : 0;
            const hurtFlash = player.isHurt && Math.floor(player.hurtTimer / 4) % 2 === 0;
            const witchTimeReady = game.witchTimeCharge.ready;
            drawPlayer(player.x, player.y, player.radius, player.angle, player.color, showChargeVisual, visualChargePercent, hurtFlash, player.isGrounded, witchTimeReady);

            // Draw targeting reticle on autoAim target
            if (player.autoAimTarget && player.reticleAnim > 0 && isEnemyOnScreen(player.autoAimTarget)) {
                const target = player.autoAimTarget;
                const t = player.reticleAnim; // 0 to 1 animation progress

                // Easing function for lock-in (starts fast, slows at end)
                const ease = 1 - Math.pow(1 - t, 3);

                // Radius starts large and shrinks to outside the enemy with gap
                const targetRadius = target.size * 0.75 + 12; // Final radius - outside enemy with gap
                const startRadius = target.size * 2.0;        // Starting radius (large)
                const radius = startRadius + (targetRadius - startRadius) * ease;

                // 4 markers rotating around target
                const rotation = player.reticleRotation;

                ctx.save();
                ctx.globalAlpha = 0.7 + 0.3 * ease; // Fade in as it locks

                for (let i = 0; i < 4; i++) {
                    const angle = rotation + (i * Math.PI / 2); // 90 degrees apart
                    const mx = target.x + Math.cos(angle) * radius;
                    const my = target.y + Math.sin(angle) * radius;

                    // Draw same arrow sprite as offscreen indicator, but smaller and pointing inward
                    ctx.save();
                    ctx.translate(mx, my);
                    ctx.rotate(angle + Math.PI); // Point toward center

                    // Same triangle shape as offscreen indicator, scaled to 50%
                    const scale = 0.5;
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.moveTo(12 * scale, 0);           // Point (toward center)
                    ctx.lineTo(-6 * scale, -8 * scale);  // Top back
                    ctx.lineTo(-3 * scale, 0);           // Inner notch
                    ctx.lineTo(-6 * scale, 8 * scale);   // Bottom back
                    ctx.closePath();
                    ctx.fill();

                    ctx.restore();
                }

                ctx.restore();
            }

            // Player parry indicator removed - using enemy rings only

            // Off-screen enemy indicator (arrow pointing to enemy cluster)
            {
                // Calculate visible area bounds
                const viewHalfW = (VIEWPORT_WIDTH / 2) / camera.zoom;
                const viewHalfH = (VIEWPORT_HEIGHT / 2) / camera.zoom;
                const viewMargin = 30;  // Margin inside screen edge to consider "visible"

                // Count visible vs off-screen enemies
                let visibleCount = 0;
                let offscreenEnemies = [];

                game.enemies.forEach(enemy => {
                    if (enemy.dead || enemy.health <= 0) return;

                    const dx = enemy.x - camera.x;
                    const dy = enemy.y - camera.y;

                    // Check if enemy is within visible area
                    const isVisible = Math.abs(dx) < viewHalfW - viewMargin &&
                                     Math.abs(dy) < viewHalfH - viewMargin;

                    if (isVisible) {
                        visibleCount++;
                    } else {
                        offscreenEnemies.push({ x: enemy.x, y: enemy.y, size: enemy.size });
                    }
                });

                // Only show indicator if:
                // 1. There are off-screen enemies
                // 2. 1 or fewer visible enemies (helps find last enemies)
                if (offscreenEnemies.length > 0 && visibleCount <= 1) {
                    // Find the CLOSEST off-screen enemy to player (not center of mass)
                    let closestEnemy = null;
                    let minDist = Infinity;
                    offscreenEnemies.forEach(e => {
                        const dist = Math.sqrt((e.x - player.x) ** 2 + (e.y - player.y) ** 2);
                        if (dist < minDist) {
                            minDist = dist;
                            closestEnemy = e;
                        }
                    });

                    if (closestEnemy) {
                        // Calculate angle from player to closest enemy
                        const angleToEnemy = Math.atan2(closestEnemy.y - player.y, closestEnemy.x - player.x);

                        // Fade based on distance only (simpler now that we check visible count)
                        const distanceFade = Math.min(1, (minDist - 100) / 400);  // Fade when closer than 500
                        const alpha = Math.max(0, Math.min(0.7, distanceFade));

                        if (alpha > 0.05) {
                            // Draw indicator on a circle around player
                            const indicatorRadius = 80;  // Distance from player center
                            const indicatorX = player.x + Math.cos(angleToEnemy) * indicatorRadius;
                            const indicatorY = player.y + Math.sin(angleToEnemy) * indicatorRadius;

                            // Draw arrow/triangle pointing outward
                            ctx.save();
                            ctx.translate(indicatorX, indicatorY);
                            ctx.rotate(angleToEnemy);
                            ctx.globalAlpha = alpha;

                            // Triangle arrow (white, no border)
                            ctx.fillStyle = '#ffffff';
                            ctx.beginPath();
                            ctx.moveTo(12, 0);      // Point
                            ctx.lineTo(-6, -8);     // Top back
                            ctx.lineTo(-3, 0);      // Inner notch
                            ctx.lineTo(-6, 8);      // Bottom back
                            ctx.closePath();
                            ctx.fill();

                            ctx.restore();
                            ctx.globalAlpha = 1;
                        }
                    }
                }
            }

            // Witch time timer indicator (around player) - COMMENTED OUT for testing
            // Use the witch time bar at top instead
            /*
            if (game.witchTime.active && !game.witchTime.circleWipe) {
                const wt = game.witchTime;
                const progress = wt.timer / wt.maxTime;
                const arcRadius = player.radius + 25;

                // Background arc
                ctx.strokeStyle = '#333333';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(player.x, player.y, arcRadius, 0, Math.PI * 2);
                ctx.stroke();

                // Progress arc
                ctx.strokeStyle = progress < 0.25 ? '#ff4444' : '#8800ff';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(player.x, player.y, arcRadius, -Math.PI / 2, -Math.PI / 2 + progress * Math.PI * 2);
                ctx.stroke();
            }
            */

            // End world space rendering (camera transform)
            ctx.restore();

            // Screen-space effects (no camera transform)

            // Witch time color filter
            if (game.witchTime.active && game.violetFilter > 0.01) {
                ctx.fillStyle = `rgba(136, 0, 255, ${game.violetFilter * 0.3})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            // Witch time circle wipe (expanding or closing) - needs screen coords
            if (game.witchTime.circleWipe) {
                const wipe = game.witchTime.circleWipe;
                // Convert wipe center to screen coords using helper
                const wipeScreen = worldToScreen(wipe.centerX, wipe.centerY);
                const screenWipeX = wipeScreen.x;
                const screenWipeY = wipeScreen.y;
                ctx.fillStyle = '#000000';
                ctx.beginPath();
                // Draw a rectangle with a circular hole
                // For expanding: hole grows from 0 to full (revealing from center)
                // For closing: hole shrinks from full to 0 (closing to center)
                ctx.rect(0, 0, canvas.width, canvas.height);
                ctx.arc(screenWipeX, screenWipeY, Math.max(0, wipe.radius), 0, Math.PI * 2, true);
                ctx.fill();
            }
            
            // UI Layer (not affected by screen shake)
            
            const inWitchTime = game.witchTime.active && !game.witchTime.circleWipe;
            
            // Witch Time Bar (shows charge when not active, shows remaining time when active)
            {
                const wtBarWidth = 450;  // 50% wider
                const wtBarHeight = 12;
                const wtBarX = (canvas.width - wtBarWidth) / 2;
                const wtBarY = 30;

                // Update flash timers
                if (game.witchTimeCharge.justFilledFlash > 0) {
                    game.witchTimeCharge.justFilledFlash--;
                }
                if (game.witchTimeCharge.hitFlash > 0) {
                    game.witchTimeCharge.hitFlash--;
                }
                if (game.witchTime.rechargeFlash > 0) {
                    game.witchTime.rechargeFlash--;
                }

                // Bar background
                ctx.fillStyle = '#1a1a2e';
                ctx.fillRect(wtBarX - 2, wtBarY - 2, wtBarWidth + 4, wtBarHeight + 4);
                ctx.fillStyle = '#2a2a4e';
                ctx.fillRect(wtBarX, wtBarY, wtBarWidth, wtBarHeight);

                let barColor;
                let fillPercent;

                if (inWitchTime) {
                    // During witch time: show remaining time (consuming)
                    fillPercent = game.witchTime.timer / game.witchTime.maxTime;
                    // Fast blink magenta/white when recharged, otherwise soft blink
                    if (game.witchTime.rechargeFlash > 0) {
                        const blinkPhase = Math.floor(Date.now() / 30) % 2;
                        barColor = blinkPhase === 0 ? '#ff00ff' : '#ffffff';
                    } else {
                        const blinkPhase = Math.floor(Date.now() / 50) % 2;
                        barColor = blinkPhase === 0 ? '#aa00ff' : '#cc66ff';
                    }
                } else {
                    // Not in witch time: show charge
                    fillPercent = game.witchTimeCharge.charge / game.witchTimeCharge.maxCharge;

                    // Blink on hit, when ready, or when just filled
                    const shouldBlink = game.witchTimeCharge.hitFlash > 0 ||
                                       game.witchTimeCharge.ready ||
                                       game.witchTimeCharge.justFilledFlash > 0;
                    if (shouldBlink) {
                        // Furious blink violet/white
                        const blinkSpeed = (game.witchTimeCharge.justFilledFlash > 0 || game.witchTimeCharge.hitFlash > 0) ? 30 : 50;
                        const blinkPhase = Math.floor(Date.now() / blinkSpeed) % 2;
                        barColor = blinkPhase === 0 ? '#ff00ff' : '#ffffff';
                    } else {
                        barColor = '#aa00ff'; // Violet when charging
                    }
                }

                ctx.fillStyle = barColor;
                ctx.fillRect(wtBarX, wtBarY, wtBarWidth * fillPercent, wtBarHeight);
            }

            // HP Bar (always visible, below witch time bar)
            {
                const hpBarWidth = 450;
                const hpBarHeight = 8;
                const hpBarX = (canvas.width - hpBarWidth) / 2;
                const hpBarY = 55; // Below witch time bar

                // Background
                ctx.fillStyle = '#1a1a2e';
                ctx.fillRect(hpBarX - 2, hpBarY - 2, hpBarWidth + 4, hpBarHeight + 4);
                ctx.fillStyle = '#2a2a4e';
                ctx.fillRect(hpBarX, hpBarY, hpBarWidth, hpBarHeight);

                // HP fill - blink when hurt (same as player)
                const hpPercent = game.player.health / game.player.maxHealth;
                const isHurtBlink = game.player.isHurt && Math.floor(game.player.hurtTimer / 4) % 2 === 0;
                ctx.fillStyle = isHurtBlink ? '#ffffff' : '#ff3333';
                ctx.fillRect(hpBarX, hpBarY, hpBarWidth * hpPercent, hpBarHeight);

                // Flash effect when low HP
                if (hpPercent < 0.3 && !game.player.isHurt) {
                    const flashPhase = Math.sin(Date.now() / 200) * 0.3 + 0.5;
                    ctx.fillStyle = `rgba(255, 0, 0, ${flashPhase * 0.3})`;
                    ctx.fillRect(hpBarX, hpBarY, hpBarWidth, hpBarHeight);
                }
            }
            
            // Always show XP, power-ups, and weapon (including during witch time)
            {
                // Reset text alignment to default before UI rendering
                ctx.textAlign = 'left';
                ctx.textBaseline = 'alphabetic';
                
                // XP Bar
                const barWidth = 450;  // 50% wider
                const barHeight = 12;
                const barX = (canvas.width - barWidth) / 2;
                const barY = canvas.height - 40;
                
                // Bar background
                ctx.fillStyle = '#1a1a2e';
                ctx.fillRect(barX - 2, barY - 2, barWidth + 4, barHeight + 4);
                ctx.fillStyle = '#2a2a4e';
                ctx.fillRect(barX, barY, barWidth, barHeight);

                // Update flash timers
                if (xpSystem.levelUpFlash > 0) xpSystem.levelUpFlash--;
                if (xpSystem.hitFlash > 0) xpSystem.hitFlash--;

                // XP fill (yellow, furious blink on hit or level up)
                const xpPercent = xpSystem.xp / xpSystem.xpToNext;
                let xpColor = '#ffdd00';
                const shouldBlink = xpSystem.levelUpFlash > 0 || xpSystem.hitFlash > 0;
                if (shouldBlink) {
                    // Furious blink - very fast alternating white/yellow
                    const blinkSpeed = xpSystem.levelUpFlash > 0 ? 30 : 40;
                    const blinkPhase = Math.floor(Date.now() / blinkSpeed) % 2;
                    xpColor = blinkPhase === 0 ? '#ffffff' : '#ffdd00';
                }
                ctx.fillStyle = xpColor;
                ctx.fillRect(barX, barY, barWidth * xpPercent, barHeight);
                
                // Row above XP bar: LVL (left) | Icons (center) | Weapon (right)
                const iconY = barY - 18;

                // Level text (aligned to left edge of XP bar)
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 14px sans-serif';
                ctx.textAlign = 'left';
                ctx.fillText(`LVL ${xpSystem.level}`, barX, iconY);

                // Weapon display (aligned to right edge of XP bar)
                const weaponName = game.weapon.name || 'SMG';
                ctx.font = 'bold 14px sans-serif';
                ctx.textAlign = 'right';
                ctx.fillStyle = game.weapon.color;
                ctx.fillText(weaponName, barX + barWidth, iconY);

                // Power-up icons (centered in the middle)
                const iconSpacing = 40;
                let totalIconWidth = 0;
                powerUpOrder.forEach(key => {
                    if (powerUps[key] > 0) totalIconWidth += iconSpacing;
                });

                const iconStartX = (canvas.width - totalIconWidth) / 2;
                let iconOffset = 0;

                powerUpOrder.forEach(key => {
                    const cfg = powerUpConfig[key];
                    const count = powerUps[key];
                    if (count > 0) {
                        const flashTimer = game.powerUpFlash[key] || 0;
                        const isFlashing = flashTimer > 0;
                        const flashPhase = Math.floor(Date.now() / 50) % 2;

                        // Update flash timer
                        if (isFlashing) {
                            game.powerUpFlash[key]--;
                        }

                        const iconX = iconStartX + iconOffset;

                        // Spawn particles if this powerup was just acquired/leveled
                        if (game.powerUpParticles && game.powerUpParticles[key]) {
                            game.powerUpParticles[key] = false;
                            // Spawn particle explosion (screen space)
                            for (let i = 0; i < 12; i++) {
                                const angle = (i / 12) * Math.PI * 2 + Math.random() * 0.3;
                                const speed = 2 + Math.random() * 3;
                                game.uiParticles.push({
                                    x: iconX + 8,
                                    y: iconY,
                                    vx: Math.cos(angle) * speed,
                                    vy: Math.sin(angle) * speed - 1,
                                    life: 20 + Math.random() * 15,
                                    maxLife: 35,
                                    radius: 2 + Math.random() * 3,
                                    color: Math.random() > 0.5 ? '#ffffff' : cfg.color
                                });
                            }
                        }

                        // Draw icon (no scale animation)
                        ctx.save();
                        ctx.font = '16px sans-serif';
                        ctx.fillStyle = isFlashing && flashPhase ? '#ffffff' : cfg.color;
                        ctx.textAlign = 'center';
                        ctx.fillText(cfg.icon, iconX + 8, iconY);
                        ctx.restore();

                        // Draw count number to the RIGHT of icon
                        ctx.font = 'bold 11px sans-serif';
                        ctx.fillStyle = isFlashing && flashPhase ? cfg.color : '#ffffff';
                        ctx.textAlign = 'left';
                        ctx.fillText(`${count}`, iconX + 20, iconY);

                        iconOffset += iconSpacing;
                    }
                });
                
                // Reset text align to default
                ctx.textAlign = 'left';

                // Update and draw UI particles (for powerup effects, etc)
                game.uiParticles = game.uiParticles.filter(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += 0.15; // Gravity
                    p.life--;

                    if (p.life <= 0) return false; // Remove dead particles

                    const alpha = Math.max(0, p.life / p.maxLife);
                    const radius = Math.max(0.1, p.radius * alpha);
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
                    ctx.fill();
                    return true;
                });
                ctx.globalAlpha = 1;
            }

            // Slot Machine UI - floating next to player (in screen space)
            if (slotMachine.active) {
                const currentOption = slotMachine.options[slotMachine.currentIndex];
                const cfg = powerUpConfig[currentOption];

                // Position floating to the right of player (convert to screen coords)
                const playerScreen = worldToScreen(player.x, player.y);
                const floatX = playerScreen.x + 50;
                const floatY = playerScreen.y - 30;
                
                // Box size
                const boxSize = 40;
                
                // Emoji vertical offset correction (emojis render slightly high)
                const emojiOffsetY = 2;

                if (slotMachine.spinning) {
                    // Spinning state - show cycling icons with colored border
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.beginPath();
                    ctx.arc(floatX, floatY, boxSize / 2 + 5, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.strokeStyle = cfg.color;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(floatX, floatY, boxSize / 2 + 5, 0, Math.PI * 2);
                    ctx.stroke();

                    // Icon centered in circle
                    ctx.font = '24px sans-serif';
                    ctx.fillStyle = '#ffffff';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(cfg.icon, floatX, floatY + emojiOffsetY);
                } else {
                    // Selected state - white blink effect
                    const blinkPhase = Math.floor(slotMachine.displayTimer / 8) % 2;
                    const isBlinking = slotMachine.displayTimer > 120; // Blink for first ~0.5s

                    if (isBlinking && blinkPhase === 0) {
                        // White flash
                        ctx.fillStyle = '#ffffff';
                        ctx.beginPath();
                        ctx.arc(floatX, floatY, boxSize / 2 + 8, 0, Math.PI * 2);
                        ctx.fill();
                    } else {
                        // Normal display with color
                        ctx.fillStyle = cfg.color;
                        ctx.globalAlpha = 0.4;
                        ctx.beginPath();
                        ctx.arc(floatX, floatY, boxSize / 2 + 5, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.globalAlpha = 1;

                        ctx.strokeStyle = cfg.color;
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(floatX, floatY, boxSize / 2 + 5, 0, Math.PI * 2);
                        ctx.stroke();
                    }

                    // Icon centered in circle
                    ctx.font = '24px sans-serif';
                    ctx.fillStyle = '#ffffff';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(cfg.icon, floatX, floatY + emojiOffsetY);
                }
                
                ctx.textBaseline = 'alphabetic'; // Reset
            }
            
            // PERFECT CLEAR overlay
            if (game.witchTime.perfectClear) {
                // More transparent overlay (0.5 instead of 0.7)
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Screen shake during perfect clear
                game.screenShake = 12;

                // Calculate text dimensions for particle spawning
                const targetWidth = canvas.width * 0.8;
                const targetHeight = canvas.height * 0.6;
                const fontSize = Math.min(targetWidth / 10, targetHeight / 1.5);
                const textWidth = fontSize * 8; // Approximate width of "PERFECT CLEAR"
                const textHeight = fontSize * 0.8;
                const textX = canvas.width / 2;
                const textY = canvas.height / 2 - 40; // Moved up

                // Spawn UI particles from text rectangle (screen space, not world space)
                if (Math.floor(game.witchTime.perfectClearTimer) % 2 === 0) {
                    for (let i = 0; i < 4; i++) {
                        // Spawn from edges of text rectangle
                        const edge = Math.floor(Math.random() * 4);
                        let px, py;
                        switch(edge) {
                            case 0: // Top
                                px = textX + (Math.random() - 0.5) * textWidth;
                                py = textY - textHeight / 2;
                                break;
                            case 1: // Bottom
                                px = textX + (Math.random() - 0.5) * textWidth;
                                py = textY + textHeight / 2;
                                break;
                            case 2: // Left
                                px = textX - textWidth / 2;
                                py = textY + (Math.random() - 0.5) * textHeight;
                                break;
                            case 3: // Right
                                px = textX + textWidth / 2;
                                py = textY + (Math.random() - 0.5) * textHeight;
                                break;
                        }
                        game.uiParticles.push({
                            x: px,
                            y: py,
                            vx: (Math.random() - 0.5) * 8,
                            vy: (Math.random() - 0.5) * 8 - 2, // Slight upward bias
                            life: 30 + Math.random() * 20,
                            maxLife: 50,
                            radius: 3 + Math.random() * 4,
                            color: Math.random() > 0.5 ? '#ffffff' : '#ff00ff'
                        });
                    }
                }

                // Draw UI particles (on top of overlay)
                game.uiParticles.forEach((p, i) => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += 0.1; // Slight gravity
                    p.life--;

                    const alpha = Math.max(0, p.life / p.maxLife);
                    const radius = Math.max(0.1, p.radius * alpha);
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
                    ctx.fill();
                });
                ctx.globalAlpha = 1;

                // Remove dead particles
                game.uiParticles = game.uiParticles.filter(p => p.life > 0 && p.maxLife > 0);

                // Blinking effect - same as enemy hit (white/color alternating every 4 frames)
                const blinkPhase = Math.floor(game.witchTime.perfectClearTimer / 4) % 2;

                // PERFECT CLEAR text - always visible but color changes
                ctx.save();
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                // Alternate between white and magenta (like enemy hit flash)
                const textColor = blinkPhase === 0 ? '#ffffff' : '#ff00ff';

                ctx.font = `bold ${fontSize}px Impact, sans-serif`;
                ctx.fillStyle = textColor;
                ctx.fillText('PERFECT CLEAR', textX, textY);

                ctx.restore();

                // Wave animation showing ALL powerups rising
                const waveProgress = game.witchTime.perfectClearWave || 0;
                const powerUpTypes = ['melee', 'gun', 'dash', 'witchTime', 'regen'];
                const waveSpacing = 30; // Frames between each powerup starting to animate
                const waveDuration = 60; // How long each powerup animation lasts

                powerUpTypes.forEach((type, i) => {
                    const cfg = powerUpConfig[type];
                    const startTime = i * waveSpacing;
                    const localProgress = (waveProgress - startTime) / waveDuration;

                    if (localProgress > 0 && localProgress < 1.5) {
                        // Position: spread across bottom, rise up then settle
                        const baseX = canvas.width / 2 + (i - 2) * 80;
                        const startY = canvas.height + 50;
                        const targetY = canvas.height / 2 + 60; // More space from text (text is at /2 - 40)

                        // Ease out bounce
                        let yProgress = Math.min(1, localProgress);
                        const easeY = 1 - Math.pow(1 - yProgress, 3); // Cubic ease out
                        const bounceY = yProgress > 0.7 ? Math.sin((yProgress - 0.7) * 10) * 5 * (1.5 - localProgress) : 0;

                        const y = startY + (targetY - startY) * easeY + bounceY;
                        const scale = 0.5 + easeY * 1.0; // Start small, grow to 1.5x
                        const alpha = Math.min(1, localProgress * 2) * Math.min(1, (1.5 - localProgress) * 2);

                        ctx.save();
                        ctx.globalAlpha = alpha;
                        ctx.translate(baseX, y);
                        ctx.scale(scale, scale);

                        // Icon (no circle background)
                        ctx.font = 'bold 48px sans-serif';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillStyle = '#ffffff';
                        ctx.fillText(cfg.icon, 0, 0);

                        // +1 text
                        ctx.font = 'bold 18px sans-serif';
                        ctx.fillStyle = '#ffffff';
                        ctx.fillText('+1', 0, 32);

                        ctx.restore();
                    }
                });
            }

            // End screen shake transform
            ctx.restore();

            // DEATH SEQUENCE OVERLAY - simplified
            if (game.death.active) {
                const death = game.death;

                // Black overlay
                ctx.fillStyle = `rgba(0, 0, 0, ${death.fadeAlpha})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Only show text in phase 0 (waiting for restart)
                if (death.phase === 0) {
                    // Screen shake like PERFECT CLEAR
                    if (death.textShakeTimer > 0) {
                        game.screenShake = 12;
                    }

                    const fontSize = Math.min(canvas.width * 0.1, 80);
                    const textX = canvas.width / 2;
                    const textY = canvas.height / 2 - 30;

                    // YOU DIED text
                    ctx.save();
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.font = `bold ${fontSize}px Impact, sans-serif`;

                    // Blinking only during shake
                    if (death.textShakeTimer > 0) {
                        const blinkPhase = Math.floor(Date.now() / 80) % 2;
                        ctx.fillStyle = blinkPhase ? '#ff0000' : '#ffffff';
                    } else {
                        ctx.fillStyle = '#ffffff';
                    }

                    ctx.fillText('YOU DIED', textX, textY);
                    ctx.restore();

                    // "Press anything to restart" text
                    if (death.canRestart) {
                        ctx.save();
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.font = 'bold 20px sans-serif';

                        // Pulsing alpha
                        const pulse = Math.sin(Date.now() / 300) * 0.3 + 0.7;
                        ctx.fillStyle = `rgba(255, 255, 255, ${pulse})`;
                        ctx.fillText('Press anything to restart', canvas.width / 2, textY + 80);
                        ctx.restore();
                    }
                }
            }

            // PAUSE SCREEN OVERLAY
            if (game.paused) {
                // Dark overlay
                ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.save();
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                // Title
                ctx.font = 'bold 48px Impact, sans-serif';
                ctx.fillStyle = '#ff00ff';
                ctx.fillText('PAUSED', canvas.width / 2, 60);

                // Controls section - 3 column layout
                const leftColX = canvas.width / 2 - 200;  // Keyboard column (right-aligned keys)
                const centerColX = canvas.width / 2;       // Action column (centered)
                const rightColX = canvas.width / 2 + 200;  // Gamepad column (left-aligned)
                let y = 120;
                const lineHeight = 28;

                ctx.font = 'bold 20px sans-serif';
                ctx.fillStyle = '#4ecca3';
                // Headers centered over their columns
                ctx.textAlign = 'right';
                ctx.fillText('KEYBOARD', leftColX + 80, y);
                ctx.textAlign = 'left';
                ctx.fillText('GAMEPAD (PS5)', rightColX - 80, y);
                y += lineHeight + 10;

                ctx.font = '16px sans-serif';
                ctx.fillStyle = '#ffffff';

                // Order: Move, Melee, Dash, W. Time, Aim, Shoot, Change Weapon, Pause
                const controls = [
                    ['WASD', 'Move', 'Left Stick'],
                    ['K', 'Melee', 'R1'],
                    ['O', 'Dash', 'L1'],
                    ['P (or dodge)', 'W. Time', 'L2 or R2 (or dodge)'],
                    ['(auto)', 'Aim', '(auto)'],
                    ['(auto)', 'Shoot', '(auto)'],
                    ['(auto)', 'Change Weapon', '(auto)'],
                    ['H', 'Pause / Help', 'Options']
                ];

                controls.forEach(([keyboard, action, gamepad]) => {
                    ctx.textAlign = 'right';
                    ctx.fillStyle = '#88ffcc';
                    ctx.fillText(keyboard, leftColX + 80, y);
                    ctx.textAlign = 'center';
                    ctx.fillStyle = '#ffffff';
                    ctx.fillText(action, centerColX, y);
                    ctx.textAlign = 'left';
                    ctx.fillStyle = '#88ffcc';
                    ctx.fillText(gamepad, rightColX - 80, y);
                    y += lineHeight;
                });

                // Power-ups section
                y += 20;
                ctx.font = 'bold 20px sans-serif';
                ctx.fillStyle = '#ff00ff';
                ctx.textAlign = 'center';
                ctx.fillText('POWER-UPS', canvas.width / 2, y);
                y += lineHeight + 5;

                ctx.font = '15px sans-serif';
                const powerUpInfo = [
                    ['ðŸ—¡ï¸', 'MELEE', 'Damage + Sword Range'],
                    ['ðŸ”«', 'GUN', 'Damage + Fire Rate'],
                    ['ðŸ’¨', 'DASH', 'Speed + Distance'],
                    ['â±ï¸', 'W. TIME', 'Duration + Enemy Slowdown'],
                    ['â¤ï¸', 'REGEN', 'HP Regen + Charge Speed']
                ];

                // Power-ups with text next to icons (left-aligned group)
                const powerUpStartX = canvas.width / 2 - 180;
                powerUpInfo.forEach(([icon, name, desc]) => {
                    ctx.textAlign = 'left';
                    ctx.font = '20px sans-serif';
                    ctx.fillStyle = '#ffffff';
                    ctx.fillText(icon, powerUpStartX, y);
                    ctx.font = 'bold 15px sans-serif';
                    ctx.fillStyle = '#ffffff';
                    ctx.fillText(name, powerUpStartX + 35, y);
                    ctx.font = '14px sans-serif';
                    ctx.fillStyle = '#aaaaaa';
                    ctx.fillText(desc, powerUpStartX + 110, y);
                    y += lineHeight;
                });

                // Press anything to resume
                y += 20;
                ctx.font = 'bold 18px sans-serif';
                const pulse = Math.sin(Date.now() / 300) * 0.3 + 0.7;
                ctx.fillStyle = `rgba(255, 255, 255, ${pulse})`;
                ctx.textAlign = 'center';
                ctx.fillText('Press anything to resume', canvas.width / 2, y);

                ctx.restore();
            }
        }

        function gameLoop() {
            const gamepads = navigator.getGamepads();
            let activeGamepad = null;
            for (const gp of gamepads) { if (gp && gp.connected) { activeGamepad = gp; break; } }

            // Copy accumulated button events (like keyboard does)
            game.buttonsJustPressed = {...game.buttonsPressedThisFrame};
            game.buttonsJustReleased = {...game.buttonsReleasedThisFrame};
            // Clear for next frame
            game.buttonsPressedThisFrame = {};
            game.buttonsReleasedThisFrame = {};

            update(activeGamepad); // Always update, gamepad can be null
            updateCamera(); // Update camera position (Hotline Miami style deadzone)
            render();
            requestAnimationFrame(gameLoop);
        }

        // High-frequency gamepad polling (faster than 60fps) to catch quick taps
        setInterval(() => {
            const gamepads = navigator.getGamepads();
            let gp = null;
            for (const g of gamepads) { if (g && g.connected) { gp = g; break; } }

            if (gp) {
                gp.buttons.forEach((btn, i) => {
                    const isPressed = btn.pressed || btn.value > 0.5;
                    const wasPressed = game.prevButtons[i] || false;

                    // Accumulate presses/releases
                    if (isPressed && !wasPressed) game.buttonsPressedThisFrame[i] = true;
                    if (!isPressed && wasPressed) game.buttonsReleasedThisFrame[i] = true;

                    // Update prevButtons immediately for next poll
                    game.prevButtons[i] = isPressed;
                });
            }
        }, 0); // Poll as fast as possible (browser will cap at ~1ms / 1000Hz)

        window.addEventListener('gamepadconnected', (e) => console.log('Gamepad connected:', e.gamepad.id));
        window.addEventListener('gamepaddisconnected', (e) => console.log('Gamepad disconnected'));

        resizeCanvas();
        // Initialize player at center of game area
        game.player.x = GAME_AREA_WIDTH / 2;
        game.player.y = GAME_AREA_HEIGHT / 2;
        // Initialize camera at player position
        camera.x = game.player.x;
        camera.y = game.player.y;
        initEnemies();
        gameLoop();
    </script>
</body>
</html>
