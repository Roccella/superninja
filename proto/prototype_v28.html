<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Super Ninja Hyper Mega Ultra</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { 
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #1a1a2e; 
        }
        #gameCanvas { 
            display: block;
            background: #16213e;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Keyboard state
        const keys = {};
        let keysJustPressed = {};
        let keysJustReleased = {};
        let keysPressedThisFrame = {};
        let keysReleasedThisFrame = {};
        
        window.addEventListener('keydown', e => {
            if (!keys[e.code]) keysPressedThisFrame[e.code] = true;
            keys[e.code] = true;
        });
        window.addEventListener('keyup', e => { 
            keys[e.code] = false; 
            keysReleasedThisFrame[e.code] = true;
        });
        
        function updateKeyboardState() {
            // Copy this frame's events to the readable state
            keysJustPressed = {...keysPressedThisFrame};
            keysJustReleased = {...keysReleasedThisFrame};
            // Clear for next frame
            keysPressedThisFrame = {};
            keysReleasedThisFrame = {};
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            if (game.player.x > canvas.width) game.player.x = canvas.width / 2;
            if (game.player.y > canvas.height) game.player.y = canvas.height / 2;
        }
        window.addEventListener('resize', resizeCanvas);

        // XP and Level system
        const xpSystem = {
            xp: 0,
            level: 1,
            xpToNext: 100,
            xpPerKill: { normal: 15, big: 35, boss: 100 }
        };

        // Power-up system
        const powerUps = {
            speed: 0,
            meleeDamage: 0,
            gunDamage: 0,
            fireRate: 0,
            spikeDamage: 0,
            chargeSpeed: 0
        };

        const powerUpConfig = {
            speed: { icon: '‚ö°', name: 'SPD', color: '#00ff88', bonus: 0.5 },
            meleeDamage: { icon: '‚öîÔ∏è', name: 'MEL', color: '#ff00ff', bonus: 0.3 },
            gunDamage: { icon: 'üî´', name: 'DMG', color: '#ff4444', bonus: 0.15 },
            fireRate: { icon: 'üî•', name: 'ROF', color: '#ffaa00', bonus: 15 },
            spikeDamage: { icon: 'üó°Ô∏è', name: 'SPK', color: '#00aaff', bonus: 0.4 },
            chargeSpeed: { icon: '‚è±Ô∏è', name: 'CHG', color: '#ff88ff', bonus: 8 }
        };

        // Slot machine state - floating next to player
        const slotMachine = {
            active: false,
            spinning: true,
            currentIndex: 0,
            spinTimer: 0,
            maxSpinTime: 240, // 4 seconds at 60fps
            options: ['speed', 'meleeDamage', 'gunDamage', 'fireRate', 'spikeDamage', 'chargeSpeed'],
            selectedOption: null,
            displayTimer: 0,
            shuffleTimer: 0
        };
        
        // Weapon system
        const weapons = {
            smg: { name: 'SMG', baseFireRate: 120, fireRate: 120, bulletSpeed: 14, baseDamage: 0.3, damage: 0.3, spread: 0.15, autoAim: 0.35, color: '#44ddff', bulletsPerShot: 1 },
            pistol: { name: 'PISTOL', baseFireRate: 300, fireRate: 300, bulletSpeed: 18, baseDamage: 1.2, damage: 1.2, spread: 0.05, autoAim: 0.4, color: '#ffff44', bulletsPerShot: 1 },
            shotgun: { name: 'SHOTGUN', baseFireRate: 500, fireRate: 500, bulletSpeed: 16, baseDamage: 0.6, damage: 0.6, spread: 0.3, autoAim: 0.25, color: '#ff8844', bulletsPerShot: 6 }
        };
        const weaponOrder = ['smg', 'pistol', 'shotgun'];
        let currentWeaponIndex = 0;

        const game = {
            player: {
                x: 600, y: 400,
                vx: 0, vy: 0,
                radius: 15,
                angle: 0,
                baseSpeed: 4.5, // Nerfed from 6
                speed: 4.5,
                dashSpeed: 22,
                isDashing: false,
                dashCooldown: 0,
                dashDuration: 0,
                dashAngle: 0,
                dashMomentum: 0,
                postDashWindow: 0,
                collisionSlowdown: 0,
                autoAimTarget: null,
                autoAimLockTimer: 0,
                color: '#4ecca3',
                meleeCooldown: 0,
                meleeFrame: 0,
                dashMeleeUsed: false,
                isChargingMelee: false,
                meleeChargeTime: 0,
                meleeChargeMax: 80, // Increased from 60, upgradeable
                baseMeleeChargeMax: 80,
                chargeReady: false,
                movementPause: 0,
                isHurt: false,
                hurtTimer: 0,
                hurtSlowdown: 0.4,
                cantAttackTimer: 0,
                isParrying: false,
                parryTarget: null,
                parryProgress: 0,
                parryTargets: [],
                isKnockedBack: false,
                knockbackTimer: 0,
                isGrounded: false,
                groundedTimer: 0,
                parryIndicator: null
            },
            currentMoveAngle: 0,
            hasMoveInput: false,
            weapon: weapons.smg, // Reference to current weapon
            bullets: [],
            enemies: [],
            particles: [],
            dustParticles: [],
            ghostTrails: [],
            slashEffects: [],
            slashDeaths: [],
            chargeParticles: [],
            shockwaves: [],
            parrySequence: null,
            lastShot: 0,
            hitFreeze: 0,
            screenShake: 0,
            prevButtons: {},
            maxEnemies: 20,
            bossSpawnTimer: 0,
            bossSpawnInterval: 1800,
            bossActive: false,
            slowMotion: 1,
            slowMotionTimer: 0,
            violetFilter: 0,
            parryCircle: null,
            parryFreeze: false,
            parryFreezeTimer: 0,
            // Witch Time (Bayonetta-style dodge)
            witchTime: {
                active: false,
                timer: 0,
                maxTime: 240, // 4 seconds at 60fps
                circleWipe: null, // For end animation
                killTimeBonus: 80 // ~1/3 of max time restored per kill
            }
        };

        const meleeAttack = { 
            arc: Math.PI * 0.9, duration: 8, baseDamage: 1.0, damage: 1.0, 
            range: 65, color: '#ffffff', knockback: 10, cooldown: 12
        };

        const chargedMeleeAttack = {
            arc: Math.PI * 1.4, duration: 18, baseDamage: 2.5, damage: 2.5,
            range: 110, color: '#ff00ff', knockback: 25, cooldown: 30
        };

        const dashMeleeAttack = {
            baseWidth: 18, width: 18, // Nerfed from 25
            baseLength: 160, length: 160, // Nerfed from 200
            offset: 40,
            baseDamage: 2.0, damage: 2.0, duration: 15, color: '#ffaa00', knockback: 20
        };

        const chargedDashCone = { angle: Math.PI * 0.6, range: 240, damage: 4 };

        const enemyAttack = {
            chargeTime: 80,
            blinkTime: 40,
            blinkDuration: 12,
            parryWindow: 40,
            damage: 1,
            range: 35,
            arc: Math.PI * 0.7,
            color: '#ff4444',
            attackPauseDuration: 60
        };

        const bossAttack = {
            chargeTime: 100,
            blinkTime: 50,
            blinkDuration: 15,
            parryWindow: 50,
            damage: 2,
            range: 50,
            arc: Math.PI * 0.8,
            knockbackForce: 25,
            knockbackDuration: 40,
            groundedDuration: 50,
            attackPauseDuration: 80
        };

        const ENEMY_NORMAL = 'normal';
        const ENEMY_BIG = 'big';
        const ENEMY_BOSS = 'boss';

        function spawnEnemyFromEdge(type = ENEMY_NORMAL) {
            const edge = Math.floor(Math.random() * 4);
            let x, y, vx, vy;
            
            const configs = {
                [ENEMY_NORMAL]: { baseSpeed: 0.5, size: 35, health: 2, color: '#e94560', aggroSpeed: 1.0, parryHealth: 1 },
                [ENEMY_BIG]: { baseSpeed: 0.3, size: 45, health: 5, color: '#5a6fd6', aggroSpeed: 0.8, parryHealth: 1 },
                [ENEMY_BOSS]: { baseSpeed: 0.2, size: 55, health: 12, color: '#d4aa00', aggroSpeed: 0.5, parryHealth: 3 }
            };
            
            const cfg = configs[type];
            const size = cfg.size;
            
            switch(edge) {
                case 0: x = Math.random() * canvas.width; y = -size; vx = (Math.random() - 0.5) * cfg.baseSpeed; vy = cfg.baseSpeed; break;
                case 1: x = canvas.width + size; y = Math.random() * canvas.height; vx = -cfg.baseSpeed; vy = (Math.random() - 0.5) * cfg.baseSpeed; break;
                case 2: x = Math.random() * canvas.width; y = canvas.height + size; vx = (Math.random() - 0.5) * cfg.baseSpeed; vy = -cfg.baseSpeed; break;
                case 3: x = -size; y = Math.random() * canvas.height; vx = cfg.baseSpeed; vy = (Math.random() - 0.5) * cfg.baseSpeed; break;
            }
            
            return {
                x, y, vx, vy,
                type: type,
                size: size,
                health: cfg.health,
                maxHealth: cfg.health,
                parryHealth: cfg.parryHealth,
                color: cfg.color,
                angle: Math.atan2(vy, vx),
                hit: 0,
                moveTimer: 60 + Math.random() * 120,
                baseSpeed: cfg.baseSpeed,
                aggroSpeed: cfg.aggroSpeed,
                aggroRange: type === ENEMY_BOSS ? 300 : 200,
                chargeRange: type === ENEMY_BOSS ? 250 : 180,
                orbitRange: type === ENEMY_BOSS ? 80 : (type === ENEMY_BIG ? 60 : 45),
                isAggro: false,
                respawnTimer: 0,
                dead: false,
                isCharging: false,
                chargeTime: 0,
                inParryWindow: false,
                hasBlinked: false,
                attackCooldown: 0,
                attackPause: 0,
                isStunned: false,
                stunTimer: 0
            };
        }

        function initEnemies() {
            game.enemies = [];
            game.slashDeaths = [];
            game.bossActive = false;
            for (let i = 0; i < game.maxEnemies; i++) {
                game.enemies.push(spawnEnemyFromEdge(i < 2 ? ENEMY_BIG : ENEMY_NORMAL));
            }
            game.bossSpawnTimer = game.bossSpawnInterval;
        }

        function spawnBoss() {
            if (game.bossActive) return;
            game.enemies.push(spawnEnemyFromEdge(ENEMY_BOSS));
            game.bossActive = true;
        }
        
        function updateAutoAim() {
            const player = game.player;
            
            // Decrement lock timer
            if (player.autoAimLockTimer > 0) player.autoAimLockTimer -= 1;
            
            // Check if current target is still valid
            if (player.autoAimTarget) {
                const target = player.autoAimTarget;
                if (target.health <= 0 || target.dead) {
                    player.autoAimTarget = null;
                    player.autoAimLockTimer = 0;
                }
            }
            
            // If locked onto a target, keep it
            if (player.autoAimTarget && player.autoAimLockTimer > 0) {
                const dx = player.autoAimTarget.x - player.x;
                const dy = player.autoAimTarget.y - player.y;
                player.angle = Math.atan2(dy, dx);
                return;
            }
            
            // Find closest enemy
            let closest = null;
            let closestDist = Infinity;
            game.enemies.forEach(enemy => {
                if (enemy.health <= 0 || enemy.dead) return;
                const dx = enemy.x - player.x;
                const dy = enemy.y - player.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < closestDist) {
                    closestDist = dist;
                    closest = enemy;
                }
            });
            
            if (closest) {
                // Lock onto new target
                if (closest !== player.autoAimTarget) {
                    player.autoAimTarget = closest;
                    player.autoAimLockTimer = 30; // Lock for 0.5 seconds
                }
                const dx = closest.x - player.x;
                const dy = closest.y - player.y;
                player.angle = Math.atan2(dy, dx);
            }
        }

        function findNearestEnemy(fromX, fromY, aimAngle, maxAngle) {
            let nearest = null;
            let nearestScore = Infinity;
            game.enemies.forEach(enemy => {
                if (enemy.health <= 0 || enemy.dead) return;
                const dx = enemy.x - fromX;
                const dy = enemy.y - fromY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const angleToEnemy = Math.atan2(dy, dx);
                let angleDiff = angleToEnemy - aimAngle;
                while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                if (Math.abs(angleDiff) < maxAngle && dist < 400) {
                    const score = dist + Math.abs(angleDiff) * 200;
                    if (score < nearestScore) {
                        nearestScore = score;
                        nearest = { enemy, angleToEnemy, dist };
                    }
                }
            });
            return nearest;
        }

        function findParryTarget(dashAngle) {
            const player = game.player;
            let bestTarget = null;
            let bestDist = Infinity;
            game.enemies.forEach(enemy => {
                if (enemy.health <= 0 || enemy.dead || !enemy.inParryWindow) return;
                const dx = enemy.x - player.x;
                const dy = enemy.y - player.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const angleToEnemy = Math.atan2(dy, dx);
                // Only check distance, can dodge in any direction
                if (dist < 200 && dist < bestDist) {
                    bestDist = dist;
                    bestTarget = { enemy, angleToEnemy, dist };
                }
            });
            return bestTarget;
        }

        function findFirstParryableEnemy() {
            const player = game.player;
            let first = null;
            let minChargeRemaining = Infinity;
            game.enemies.forEach(enemy => {
                if (enemy.health <= 0 || enemy.dead || !enemy.isCharging) return;
                const dx = enemy.x - player.x;
                const dy = enemy.y - player.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < 200) {
                    const attackConfig = enemy.type === ENEMY_BOSS ? bossAttack : enemyAttack;
                    const remaining = attackConfig.chargeTime - enemy.chargeTime;
                    if (remaining < minChargeRemaining) {
                        minChargeRemaining = remaining;
                        first = enemy;
                    }
                }
            });
            return first;
        }

        function findNearbyEnemies(x, y, radius, exclude = []) {
            const nearby = [];
            game.enemies.forEach(enemy => {
                if (enemy.health <= 0 || enemy.dead) return;
                if (exclude.includes(enemy)) return;
                const dx = enemy.x - x;
                const dy = enemy.y - y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < radius) nearby.push(enemy);
            });
            return nearby;
        }

        function spawnParticles(x, y, color, count = 5, speed = 4) {
            // Limit total particles
            if (game.particles.length > 200) return;
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const spd = 2 + Math.random() * speed;
                game.particles.push({
                    x, y, vx: Math.cos(angle) * spd, vy: Math.sin(angle) * spd,
                    life: 30 + Math.random() * 20, maxLife: 50,
                    radius: 2 + Math.random() * 3, color
                });
            }
        }

        function spawnShockwave(x, y, color, maxRadius = 60) {
            game.shockwaves.push({ x, y, radius: 20, maxRadius, life: 15, maxLife: 15, color });
        }

        function spawnDust(x, y, moveAngle) {
            for (let i = 0; i < 8; i++) {
                const angle = moveAngle + Math.PI + (Math.random() - 0.5) * 1.2;
                const spd = 1 + Math.random() * 2;
                game.dustParticles.push({
                    x: x + (Math.random() - 0.5) * 10, y: y + (Math.random() - 0.5) * 10,
                    vx: Math.cos(angle) * spd, vy: Math.sin(angle) * spd,
                    life: 20 + Math.random() * 15, maxLife: 35, radius: 3 + Math.random() * 4
                });
            }
        }

        function addGhostTrail() {
            const player = game.player;
            game.ghostTrails.push({ x: player.x, y: player.y, angle: player.angle, radius: player.radius, life: 15, maxLife: 15 });
        }

        function createSlashEffect(attack, angle, x, y, trackPlayer = false, isCharged = false) {
            game.slashEffects.push({
                x, y, angle: angle + (attack.startAngle || 0),
                arc: attack.arc, range: attack.range,
                life: attack.duration, maxLife: attack.duration,
                color: attack.color, type: 'arc', trackPlayer, isCharged
            });
        }

        function createThrustEffect(x, y, angle, width, length, offset, duration, color) {
            game.slashEffects.push({
                x, y, angle, width, length, offset,
                life: duration, maxLife: duration, color, type: 'thrust', trackPlayer: false
            });
        }

        function createPiece(x, y, size, color, type, angle, side) {
            return { x, y, size, color, type, cutAngle: angle, side };
        }

        function startParrySequence(mainEnemy, nearbyEnemies, playerAngle) {
            const player = game.player;
            const mainDies = mainEnemy.parryHealth <= 1;
            if (!mainDies) {
                mainEnemy.parryHealth--;
                mainEnemy.health -= 3;
                mainEnemy.isStunned = true;
                mainEnemy.stunTimer = 90;
                mainEnemy.isCharging = false;
                mainEnemy.chargeTime = 0;
                mainEnemy.inParryWindow = false;
                mainEnemy.hasBlinked = false;
            }
            
            const cutAngle = playerAngle;
            
            game.parrySequence = {
                phase: 0,
                timer: 0,
                mainEnemy: {
                    x: mainEnemy.x, y: mainEnemy.y,
                    size: mainEnemy.size, color: mainEnemy.color, type: mainEnemy.type,
                    dies: mainDies, cutAngle: cutAngle, pieces: null, enemy: mainEnemy,
                    blinkTimer: mainDies ? 20 : 0
                },
                nearbyEnemies: nearbyEnemies.map(e => ({
                    x: e.x, y: e.y, size: e.size, color: e.color, type: e.type,
                    cutAngle: Math.atan2(e.y - player.y, e.x - player.x),
                    pieces: null, enemy: e,
                    blinkTimer: 20
                })),
                slashLines: []
            };
            
            // Award XP for kills
            if (mainDies) {
                mainEnemy.dead = true;
                mainEnemy.respawnTimer = 200 + Math.random() * 100;
                if (mainEnemy.type === ENEMY_BOSS) game.bossActive = false;
                addXP(mainEnemy.type);
            }
            nearbyEnemies.forEach(e => {
                e.dead = true;
                e.respawnTimer = 200 + Math.random() * 100;
                if (e.type === ENEMY_BOSS) game.bossActive = false;
                addXP(e.type);
            });
        }

        function updateParrySequence(timeScale) {
            const seq = game.parrySequence;
            if (!seq) return;
            
            seq.timer += timeScale;
            const phaseDuration = 25;
            
            // Update blink timers
            if (seq.mainEnemy.blinkTimer > 0) seq.mainEnemy.blinkTimer -= timeScale;
            seq.nearbyEnemies.forEach(e => { if (e.blinkTimer > 0) e.blinkTimer -= timeScale; });
            
            if (seq.phase === 0 && seq.timer >= 5) {
                seq.phase = 1;
                seq.timer = 0;
                const m = seq.mainEnemy;
                if (m.dies) {
                    m.pieces = [
                        createPiece(m.x, m.y, m.size, m.color, m.type, m.cutAngle, 1),
                        createPiece(m.x, m.y, m.size, m.color, m.type, m.cutAngle, -1)
                    ];
                    seq.slashLines.push({ x: m.x, y: m.y, angle: m.cutAngle, life: 30, maxLife: 30, length: m.size * 1.5 });
                } else {
                    seq.slashLines.push({ x: m.x, y: m.y, angle: m.cutAngle, life: 30, maxLife: 30, length: m.size * 1.2 });
                    seq.slashLines.push({ x: m.x + (Math.random()-0.5)*m.size*0.5, y: m.y + (Math.random()-0.5)*m.size*0.5, angle: Math.random() * Math.PI, life: 30, maxLife: 30, length: m.size * 0.8 });
                    seq.slashLines.push({ x: m.x + (Math.random()-0.5)*m.size*0.5, y: m.y + (Math.random()-0.5)*m.size*0.5, angle: Math.random() * Math.PI, life: 30, maxLife: 30, length: m.size * 0.8 });
                }
                spawnParticles(m.x, m.y, '#ffffff', 15, 8);
                game.screenShake = 8;
            }
            
            if (seq.phase === 1 && seq.timer >= phaseDuration) {
                seq.phase = 2;
                seq.timer = 0;
                const m = seq.mainEnemy;
                if (m.dies && m.pieces) {
                    const perpAngle = m.cutAngle + Math.PI / 2;
                    m.pieces[0].x += Math.cos(perpAngle) * 8;
                    m.pieces[0].y += Math.sin(perpAngle) * 8;
                    m.pieces[1].x -= Math.cos(perpAngle) * 8;
                    m.pieces[1].y -= Math.sin(perpAngle) * 8;
                    const newPieces = [];
                    m.pieces.forEach(p => {
                        const newCutAngle = m.cutAngle + Math.PI / 2;
                        newPieces.push(createPiece(p.x, p.y, p.size * 0.6, p.color, p.type, newCutAngle, 1));
                        newPieces.push(createPiece(p.x, p.y, p.size * 0.6, p.color, p.type, newCutAngle, -1));
                        seq.slashLines.push({ x: p.x, y: p.y, angle: newCutAngle, life: 30, maxLife: 30, length: p.size * 0.8 });
                    });
                    m.pieces = newPieces;
                }
                seq.nearbyEnemies.forEach(e => {
                    e.pieces = [
                        createPiece(e.x, e.y, e.size, e.color, e.type, e.cutAngle, 1),
                        createPiece(e.x, e.y, e.size, e.color, e.type, e.cutAngle, -1)
                    ];
                    seq.slashLines.push({ x: e.x, y: e.y, angle: e.cutAngle, life: 30, maxLife: 30, length: e.size * 1.5 });
                    spawnParticles(e.x, e.y, '#ffffff', 10, 6);
                });
                game.screenShake = 10;
            }
            
            if (seq.phase === 2 && seq.timer >= phaseDuration) {
                seq.phase = 3;
                seq.timer = 0;
                seq.nearbyEnemies.forEach(e => {
                    if (e.pieces) {
                        const newPieces = [];
                        e.pieces.forEach(p => {
                            const perpAngle = e.cutAngle + Math.PI / 2;
                            p.x += Math.cos(perpAngle) * p.side * 6;
                            p.y += Math.sin(perpAngle) * p.side * 6;
                            const newCutAngle = e.cutAngle + Math.PI / 2;
                            newPieces.push(createPiece(p.x, p.y, p.size * 0.6, p.color, p.type, newCutAngle, 1));
                            newPieces.push(createPiece(p.x, p.y, p.size * 0.6, p.color, p.type, newCutAngle, -1));
                            seq.slashLines.push({ x: p.x, y: p.y, angle: newCutAngle, life: 30, maxLife: 30, length: p.size * 0.8 });
                        });
                        e.pieces = newPieces;
                    }
                });
                game.screenShake = 8;
            }
            
            if (seq.phase === 3 && seq.timer >= phaseDuration) {
                seq.phase = 4;
                seq.timer = 0;
                const m = seq.mainEnemy;
                if (m.dies && m.pieces) {
                    m.pieces.forEach(p => {
                        spawnParticles(p.x, p.y, p.color, 8, 6);
                        spawnParticles(p.x, p.y, '#ff0000', 5, 4);
                    });
                }
                seq.nearbyEnemies.forEach(e => {
                    if (e.pieces) {
                        e.pieces.forEach(p => {
                            spawnParticles(p.x, p.y, p.color, 6, 5);
                            spawnParticles(p.x, p.y, '#ff0000', 4, 3);
                        });
                    }
                });
                game.screenShake = 12;
            }
            
            if (seq.phase === 4 && seq.timer >= 30) {
                game.parrySequence = null;
            }
            
            seq.slashLines = seq.slashLines.filter(s => { s.life -= timeScale; return s.life > 0; });
            
            if (seq.mainEnemy.pieces) {
                seq.mainEnemy.pieces.forEach(p => {
                    const perpAngle = p.cutAngle + Math.PI / 2;
                    p.x += Math.cos(perpAngle) * p.side * 0.5 * timeScale;
                    p.y += Math.sin(perpAngle) * p.side * 0.5 * timeScale;
                });
            }
            seq.nearbyEnemies.forEach(e => {
                if (e.pieces) {
                    e.pieces.forEach(p => {
                        const perpAngle = p.cutAngle + Math.PI / 2;
                        p.x += Math.cos(perpAngle) * p.side * 0.5 * timeScale;
                        p.y += Math.sin(perpAngle) * p.side * 0.5 * timeScale;
                    });
                }
            });
        }

        function killEnemy(enemy, playerX, playerY, useSlashEffect = true) {
            enemy.dead = true;
            enemy.respawnTimer = 120 + Math.random() * 120;
            if (enemy.type === ENEMY_BOSS) game.bossActive = false;
            addXP(enemy.type);
            if (useSlashEffect && game.slashDeaths.length < 15) {
                const slashAngle = Math.atan2(enemy.y - playerY, enemy.x - playerX);
                game.slashDeaths.push({
                    x: enemy.x, y: enemy.y, size: enemy.size, color: enemy.color, type: enemy.type,
                    slashAngle, phase: 'flash', timer: 0, separation: 0
                });
            } else {
                spawnParticles(enemy.x, enemy.y, '#ff0000', 8);
            }
        }

        // XP and Level functions
        function addXP(enemyType) {
            const xpGain = xpSystem.xpPerKill[enemyType] || 10;
            xpSystem.xp += xpGain;
            
            if (xpSystem.xp >= xpSystem.xpToNext) {
                levelUp();
            }
        }

        function levelUp() {
            xpSystem.level++;
            xpSystem.xp = xpSystem.xp - xpSystem.xpToNext;
            xpSystem.xpToNext = Math.floor(xpSystem.xpToNext * 1.5);
            
            // Start slot machine
            startSlotMachine();
        }

        function startSlotMachine() {
            slotMachine.active = true;
            slotMachine.spinning = true;
            slotMachine.spinTimer = 0;
            slotMachine.shuffleTimer = 0;
            slotMachine.currentIndex = Math.floor(Math.random() * slotMachine.options.length);
            slotMachine.selectedOption = null;
            slotMachine.displayTimer = 0;
            // No slowmo - game continues normally
        }

        function stopSlotMachine() {
            slotMachine.spinning = false;
            slotMachine.selectedOption = slotMachine.options[slotMachine.currentIndex];
            applyPowerUp(slotMachine.selectedOption);
            slotMachine.displayTimer = 150; // ~2.5 seconds display
        }

        function endSlotMachine() {
            slotMachine.active = false;
            slotMachine.selectedOption = null;
        }

        function applyPowerUp(type) {
            powerUps[type]++;
            
            // Recalculate stats
            game.player.speed = game.player.baseSpeed + (powerUps.speed * powerUpConfig.speed.bonus);
            meleeAttack.damage = meleeAttack.baseDamage + (powerUps.meleeDamage * powerUpConfig.meleeDamage.bonus);
            chargedMeleeAttack.damage = chargedMeleeAttack.baseDamage + (powerUps.meleeDamage * powerUpConfig.meleeDamage.bonus * 2);
            dashMeleeAttack.damage = dashMeleeAttack.baseDamage + (powerUps.meleeDamage * powerUpConfig.meleeDamage.bonus * 1.5);
            
            // Spike upgrades (size and damage)
            dashMeleeAttack.width = dashMeleeAttack.baseWidth + (powerUps.spikeDamage * 4);
            dashMeleeAttack.length = dashMeleeAttack.baseLength + (powerUps.spikeDamage * 25);
            dashMeleeAttack.damage = dashMeleeAttack.baseDamage + (powerUps.spikeDamage * powerUpConfig.spikeDamage.bonus);
            
            // Charge speed upgrade
            game.player.meleeChargeMax = Math.max(30, game.player.baseMeleeChargeMax - (powerUps.chargeSpeed * powerUpConfig.chargeSpeed.bonus));
            
            // Apply gun upgrades to all weapons
            Object.keys(weapons).forEach(wKey => {
                const w = weapons[wKey];
                w.damage = w.baseDamage + (powerUps.gunDamage * powerUpConfig.gunDamage.bonus);
                w.fireRate = Math.max(30, w.baseFireRate - (powerUps.fireRate * powerUpConfig.fireRate.bonus));
            });
        }
        
        function cycleWeapon() {
            currentWeaponIndex = (currentWeaponIndex + 1) % weaponOrder.length;
            game.weapon = weapons[weaponOrder[currentWeaponIndex]];
        }

        function updateSlotMachine(timeScale) {
            if (!slotMachine.active) return;
            
            if (slotMachine.spinning) {
                slotMachine.spinTimer += timeScale;
                slotMachine.shuffleTimer += timeScale;
                
                // Calculate shuffle interval - starts fast (2 frames), slows to 12 frames
                const progress = slotMachine.spinTimer / slotMachine.maxSpinTime;
                const easeProgress = progress * progress; // Quadratic ease-out for deceleration
                const minInterval = 4;
                const maxInterval = 18;
                const currentInterval = minInterval + (maxInterval - minInterval) * easeProgress;
                
                // Shuffle to next icon
                if (slotMachine.shuffleTimer >= currentInterval) {
                    slotMachine.shuffleTimer = 0;
                    slotMachine.currentIndex = (slotMachine.currentIndex + 1) % slotMachine.options.length;
                }
                
                // Auto-stop after 3 seconds
                if (slotMachine.spinTimer >= slotMachine.maxSpinTime) {
                    stopSlotMachine();
                }
            } else if (slotMachine.displayTimer > 0) {
                slotMachine.displayTimer -= timeScale;
                if (slotMachine.displayTimer <= 0) {
                    endSlotMachine();
                }
            }
        }

        function stunEnemy(enemy) {
            enemy.isStunned = true;
            enemy.stunTimer = 30;
            enemy.isCharging = false;
            enemy.chargeTime = 0;
            enemy.inParryWindow = false;
            enemy.hasBlinked = false;
        }

        function damagePlayer(fromX, fromY, isBossAttack = false) {
            const player = game.player;
            if (player.isParrying) return;
            player.isHurt = true;
            player.hurtTimer = 45;
            player.cantAttackTimer = 20;
            const angle = Math.atan2(player.y - fromY, player.x - fromX);
            if (isBossAttack) {
                player.isKnockedBack = true;
                player.knockbackTimer = bossAttack.knockbackDuration;
                player.vx = Math.cos(angle) * bossAttack.knockbackForce;
                player.vy = Math.sin(angle) * bossAttack.knockbackForce;
                game.screenShake = 15;
            } else {
                player.vx = Math.cos(angle) * 8;
                player.vy = Math.sin(angle) * 8;
                game.screenShake = 10;
            }
            spawnParticles(player.x, player.y, '#ff0000', 15, 6);
        }

        function checkThrustHit(enemy, playerX, playerY, attackAngle, attackLength, attackWidth, attackOffset, damage, knockback) {
            const dx = enemy.x - playerX;
            const dy = enemy.y - playerY;
            const cos = Math.cos(-attackAngle);
            const sin = Math.sin(-attackAngle);
            const localX = dx * cos - dy * sin;
            const localY = dx * sin + dy * cos;
            const hitRadius = enemy.size / 2;
            if (localX > attackOffset && localX < attackOffset + attackLength + hitRadius &&
                Math.abs(localY) < attackWidth / 2 + hitRadius) {
                enemy.health -= damage;
                enemy.hit = 15;
                stunEnemy(enemy);
                enemy.x += Math.cos(attackAngle) * knockback;
                enemy.y += Math.sin(attackAngle) * knockback;
                return true;
            }
            return false;
        }

        function checkConeHit(enemy, playerX, playerY, coneAngle, coneArc, coneRange, damage, knockback) {
            const dx = enemy.x - playerX;
            const dy = enemy.y - playerY;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const hitRadius = enemy.size / 2;
            if (dist < coneRange + hitRadius) {
                let angle = Math.atan2(dy, dx);
                let angleDiff = angle - coneAngle;
                while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                if (Math.abs(angleDiff) < coneArc / 2) {
                    enemy.health -= damage;
                    enemy.hit = 15;
                    stunEnemy(enemy);
                    enemy.x += Math.cos(angle) * knockback;
                    enemy.y += Math.sin(angle) * knockback;
                    return true;
                }
            }
            return false;
        }

        function checkArcHit(enemy, playerX, playerY, attackAngle, arc, range, damage, knockback) {
            const dx = enemy.x - playerX;
            const dy = enemy.y - playerY;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const hitRadius = enemy.size / 2;
            if (dist < range + hitRadius) {
                let angle = Math.atan2(dy, dx);
                const hitAngleStart = attackAngle - arc / 2;
                const hitAngleEnd = attackAngle + arc / 2;
                while (angle < hitAngleStart - Math.PI) angle += Math.PI * 2;
                while (angle > hitAngleStart + Math.PI) angle -= Math.PI * 2;
                if (angle >= hitAngleStart && angle <= hitAngleEnd) {
                    enemy.health -= damage;
                    enemy.hit = 15;
                    stunEnemy(enemy);
                    const knockAngle = Math.atan2(dy, dx);
                    enemy.x += Math.cos(knockAngle) * Math.min(knockback, dist * 0.4);
                    enemy.y += Math.sin(knockAngle) * Math.min(knockback, dist * 0.4);
                    return { hit: true, knockAngle };
                }
            }
            return { hit: false };
        }

        function stopDash() {
            const player = game.player;
            player.isDashing = false;
            player.dashDuration = 0;
            player.vx = 0;
            player.vy = 0;
            player.movementPause = 12;
            player.dashMomentum = 0;
        }

        function startParry(target) {
            const player = game.player;
            const enemy = target.enemy;
            
            // Cancel enemy attack
            enemy.isCharging = false;
            enemy.chargeTime = 0;
            enemy.inParryWindow = false;
            enemy.hasBlinked = false;
            enemy.isStunned = true;
            enemy.stunTimer = 300; // Stunned for duration of witch time
            
            // Stun all nearby enemies too
            game.enemies.forEach(e => {
                if (e.health <= 0 || e.dead) return;
                const dx = e.x - player.x;
                const dy = e.y - player.y;
                if (Math.sqrt(dx * dx + dy * dy) < 300) {
                    e.isStunned = true;
                    e.stunTimer = 300;
                    e.isCharging = false;
                    e.chargeTime = 0;
                    e.inParryWindow = false;
                    e.hasBlinked = false;
                }
            });
            
            // Activate Witch Time
            game.witchTime.active = true;
            game.witchTime.timer = game.witchTime.maxTime;
            game.witchTime.circleWipe = null;
            game.slowMotion = 0.15;
            game.violetFilter = 0.4;
            
            // Visual feedback
            spawnShockwave(player.x, player.y, '#8800ff', 150);
            game.screenShake = 10;
            
            // Small dash towards enemy
            player.dashAngle = Math.atan2(enemy.y - player.y, enemy.x - player.x);
            player.vx = Math.cos(player.dashAngle) * 15;
            player.vy = Math.sin(player.dashAngle) * 15;
            player.isDashing = true;
            player.dashDuration = 15;
            
            spawnDust(player.x, player.y, player.dashAngle);
        }

        function endWitchTime() {
            const player = game.player;
            
            // Start circle wipe animation (closes inward to player)
            game.witchTime.circleWipe = {
                radius: Math.max(canvas.width, canvas.height),
                targetRadius: 0,
                speed: Math.max(canvas.width, canvas.height) / 20, // ~20 frames
                centerX: player.x,
                centerY: player.y
            };
        }

        function updateWitchTime(timeScale) {
            if (!game.witchTime.active) return;
            
            // Circle wipe animation
            if (game.witchTime.circleWipe) {
                const wipe = game.witchTime.circleWipe;
                wipe.radius -= wipe.speed;
                
                if (wipe.radius <= 0) {
                    // End witch time completely
                    game.witchTime.active = false;
                    game.witchTime.circleWipe = null;
                    game.slowMotion = 1;
                    game.violetFilter = 0;
                }
                return;
            }
            
            // Count down timer (in real time, not slow-mo time)
            game.witchTime.timer -= 1;
            
            // Flash warning when about to end
            if (game.witchTime.timer < 60) {
                game.violetFilter = 0.4 + Math.sin(game.witchTime.timer * 0.3) * 0.2;
            }
            
            if (game.witchTime.timer <= 0) {
                endWitchTime();
            }
        }

        // Track enemy pieces for recursive cutting
        const enemyPieces = [];

        function createEnemyPiece(x, y, size, color, type, health = 1) {
            return {
                x, y, size, color, type, health,
                angle: Math.random() * Math.PI * 2,
                vx: 0, vy: 0,
                hit: 0
            };
        }

        function sliceEnemyOrPiece(target, slashAngle, isEnemy = true) {
            const player = game.player;
            
            // Restore witch time on kill
            if (game.witchTime.active && !game.witchTime.circleWipe) {
                game.witchTime.timer = Math.min(game.witchTime.maxTime, game.witchTime.timer + game.witchTime.killTimeBonus);
            }
            
            if (isEnemy) {
                // Kill the enemy
                target.dead = true;
                target.respawnTimer = 200 + Math.random() * 100;
                if (target.type === ENEMY_BOSS) game.bossActive = false;
                addXP(target.type);
                
                // Create pieces if under limit
                if (enemyPieces.length < 30) {
                    const piece1 = createEnemyPiece(target.x, target.y, target.size * 0.7, target.color, target.type);
                    const piece2 = createEnemyPiece(target.x, target.y, target.size * 0.7, target.color, target.type);
                    
                    const perpAngle = slashAngle + Math.PI / 2;
                    piece1.vx = Math.cos(perpAngle) * 3;
                    piece1.vy = Math.sin(perpAngle) * 3;
                    piece2.vx = -Math.cos(perpAngle) * 3;
                    piece2.vy = -Math.sin(perpAngle) * 3;
                    piece1.cutAngle = slashAngle;
                    piece2.cutAngle = slashAngle;
                    piece1.side = 1;
                    piece2.side = -1;
                    
                    enemyPieces.push(piece1, piece2);
                }
            } else {
                // Slice a piece into smaller pieces
                target.health = 0;
                
                // Only subdivide if piece is big enough and under limit
                if (target.size > 15 && enemyPieces.length < 30) {
                    const piece1 = createEnemyPiece(target.x, target.y, target.size * 0.7, target.color, target.type);
                    const piece2 = createEnemyPiece(target.x, target.y, target.size * 0.7, target.color, target.type);
                    
                    const perpAngle = slashAngle + Math.PI / 2;
                    piece1.vx = target.vx + Math.cos(perpAngle) * 2;
                    piece1.vy = target.vy + Math.sin(perpAngle) * 2;
                    piece2.vx = target.vx - Math.cos(perpAngle) * 2;
                    piece2.vy = target.vy - Math.sin(perpAngle) * 2;
                    piece1.cutAngle = slashAngle;
                    piece2.cutAngle = slashAngle;
                    piece1.side = 1;
                    piece2.side = -1;
                    
                    enemyPieces.push(piece1, piece2);
                }
                
                spawnParticles(target.x, target.y, target.color, 5, 3);
            }
            
            // Slash line effect
            if (game.slashDeaths.length < 20) {
                game.slashDeaths.push({
                    x: target.x, y: target.y,
                    size: target.size,
                    color: target.color,
                    type: target.type,
                    slashAngle: slashAngle,
                    phase: 'line',
                    timer: 0,
                    separation: 0
                });
            }
            
            spawnParticles(target.x, target.y, '#ffffff', 6, 4);
            game.screenShake = 6;
            game.hitFreeze = 4;
        }

        function executeParryDash() {
            const player = game.player;
            player.vx = Math.cos(player.dashAngle) * player.dashSpeed;
            player.vy = Math.sin(player.dashAngle) * player.dashSpeed;
            player.isDashing = true;
            player.dashDuration = 45;
            game.slowMotion = 0.15;
            game.slowMotionTimer = 150;
            game.violetFilter = 0.6;
            
            spawnDust(player.x, player.y, player.dashAngle);
            addGhostTrail();
        }

        function endParry() {
            const player = game.player;
            game.slowMotion = 1;
            game.violetFilter = 0;
            game.parryCircle = null;
            player.isParrying = false;
            player.parryTarget = null;
            player.parryTargets = [];
            player.dashSpeed = 22;
        }

        function chargedDashMeleeAttack() {
            const player = game.player;
            player.dashMeleeUsed = true;
            // Use dashAngle if dashing, otherwise use player.angle
            const thrustAngle = player.isDashing ? player.dashAngle : player.angle;
            
            // Larger offset so spikes don't overlap at origin
            const baseOffset = dashMeleeAttack.offset + 20;
            
            // Main spike (center)
            createThrustEffect(player.x, player.y, thrustAngle, dashMeleeAttack.width, dashMeleeAttack.length, baseOffset, dashMeleeAttack.duration, dashMeleeAttack.color);
            
            // Side spikes with more spread (45 degrees instead of ~23)
            createThrustEffect(player.x, player.y, thrustAngle + Math.PI * 0.3, dashMeleeAttack.width * 0.85, dashMeleeAttack.length * 0.9, baseOffset + 10, dashMeleeAttack.duration, dashMeleeAttack.color);
            createThrustEffect(player.x, player.y, thrustAngle - Math.PI * 0.3, dashMeleeAttack.width * 0.85, dashMeleeAttack.length * 0.9, baseOffset + 10, dashMeleeAttack.duration, dashMeleeAttack.color);
            
            // Inner spikes
            createThrustEffect(player.x, player.y, thrustAngle + Math.PI * 0.15, dashMeleeAttack.width * 0.7, dashMeleeAttack.length * 0.75, baseOffset + 5, dashMeleeAttack.duration, dashMeleeAttack.color);
            createThrustEffect(player.x, player.y, thrustAngle - Math.PI * 0.15, dashMeleeAttack.width * 0.7, dashMeleeAttack.length * 0.75, baseOffset + 5, dashMeleeAttack.duration, dashMeleeAttack.color);
            
            createSlashEffect(chargedMeleeAttack, thrustAngle, player.x, player.y, false, true);
            if (player.isDashing) stopDash();
            
            let hitSomething = false;
            game.enemies.forEach(enemy => {
                if (enemy.health <= 0 || enemy.dead) return;
                if (checkConeHit(enemy, player.x, player.y, thrustAngle, chargedDashCone.angle, chargedDashCone.range, chargedDashCone.damage, chargedMeleeAttack.knockback)) {
                    hitSomething = true;
                    spawnParticles(enemy.x, enemy.y, chargedMeleeAttack.color, 20, 10);
                    if (enemy.health <= 0) killEnemy(enemy, player.x, player.y);
                }
            });
            
            // Reduced freeze during witch time
            const inWitchTime = game.witchTime.active && !game.witchTime.circleWipe;
            if (hitSomething) { 
                game.hitFreeze = inWitchTime ? 3 : 15; 
                game.screenShake = 12; 
            }
            player.meleeCooldown = 20;
        }

        function dashMeleeAttackHit() {
            const player = game.player;
            player.dashMeleeUsed = true;
            // Use dashAngle if dashing, otherwise use player.angle (for witch time thrusts)
            const thrustAngle = player.isDashing ? player.dashAngle : player.angle;
            createThrustEffect(player.x, player.y, thrustAngle, dashMeleeAttack.width, dashMeleeAttack.length, dashMeleeAttack.offset, dashMeleeAttack.duration, dashMeleeAttack.color);
            if (player.isDashing) stopDash();
            let hitSomething = false;
            game.enemies.forEach(enemy => {
                if (enemy.health <= 0 || enemy.dead) return;
                if (checkThrustHit(enemy, player.x, player.y, thrustAngle, dashMeleeAttack.length, dashMeleeAttack.width, dashMeleeAttack.offset, dashMeleeAttack.damage, dashMeleeAttack.knockback)) {
                    hitSomething = true;
                    spawnParticles(enemy.x, enemy.y, dashMeleeAttack.color, 15, 8);
                    if (enemy.health <= 0) killEnemy(enemy, player.x, player.y);
                }
            });
            // Reduced freeze during witch time
            const inWitchTime = game.witchTime.active && !game.witchTime.circleWipe;
            if (hitSomething) { 
                game.hitFreeze = inWitchTime ? 2 : 10; 
                game.screenShake = 8; 
            }
            // Add small cooldown for thrust
            player.meleeCooldown = 15;
        }

        function executeMeleeAttack(isCharged) {
            const player = game.player;
            const attack = isCharged ? chargedMeleeAttack : meleeAttack;
            player.meleeFrame = attack.duration;
            player.meleeCooldown = attack.cooldown;
            createSlashEffect(attack, player.angle, player.x, player.y, true, isCharged);
            let hitSomething = false;
            
            // Hit enemies
            game.enemies.forEach(enemy => {
                if (enemy.health <= 0 || enemy.dead) return;
                const result = checkArcHit(enemy, player.x, player.y, player.angle, attack.arc, attack.range, attack.damage, attack.knockback);
                if (result.hit) {
                    hitSomething = true;
                    
                    // During witch time, slice enemies in half instead of normal damage
                    if (game.witchTime.active && !game.witchTime.circleWipe) {
                        sliceEnemyOrPiece(enemy, player.angle, true);
                    } else {
                        spawnParticles(enemy.x, enemy.y, attack.color, isCharged ? 20 : 12, isCharged ? 10 : 6);
                        if (enemy.health <= 0) killEnemy(enemy, player.x, player.y);
                    }
                }
            });
            
            // During witch time, also hit pieces
            if (game.witchTime.active && !game.witchTime.circleWipe) {
                enemyPieces.forEach(piece => {
                    if (piece.health <= 0) return;
                    const dx = piece.x - player.x;
                    const dy = piece.y - player.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < attack.range + piece.size / 2) {
                        let angleToP = Math.atan2(dy, dx);
                        let angleDiff = angleToP - player.angle;
                        while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                        while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                        if (Math.abs(angleDiff) < attack.arc / 2) {
                            hitSomething = true;
                            sliceEnemyOrPiece(piece, player.angle, false);
                        }
                    }
                });
            }
            
            if (hitSomething) { 
                // Reduced freeze during witch time
                const freezeMult = game.witchTime.active ? 0.2 : 1;
                game.hitFreeze = (isCharged ? 15 : 6) * freezeMult; 
                game.screenShake = isCharged ? 12 : 6; 
            }
        }

        function startChargingMelee() {
            const player = game.player;
            if (!player.isChargingMelee && player.meleeCooldown <= 0 && player.cantAttackTimer <= 0) {
                player.isChargingMelee = true;
                player.meleeChargeTime = 0;
                player.chargeReady = false;
            }
        }

        function releaseMelee() {
            const player = game.player;
            
            if (player.isChargingMelee) {
                const isFullyCharged = player.chargeReady;
                // Always do normal melee attack (no thrusts)
                if (player.meleeCooldown <= 0 && player.cantAttackTimer <= 0 && !player.isDashing) {
                    executeMeleeAttack(isFullyCharged);
                }
                player.isChargingMelee = false;
                player.meleeChargeTime = 0;
                player.chargeReady = false;
            }
        }

        function shoot() {
            const player = game.player;
            if (player.cantAttackTimer > 0 || player.isKnockedBack || player.isGrounded) return;
            const now = Date.now();
            if (now - game.lastShot < game.weapon.fireRate) return;
            game.lastShot = now;
            
            // Use player.angle directly - autoaim already set it
            const aimAngle = player.angle;
            
            // Fire multiple bullets for shotgun
            const bulletsToFire = game.weapon.bulletsPerShot || 1;
            for (let i = 0; i < bulletsToFire; i++) {
                const spread = (Math.random() - 0.5) * game.weapon.spread * 2;
                const angle = aimAngle + spread;
                game.bullets.push({
                    x: player.x + Math.cos(aimAngle) * 25, y: player.y + Math.sin(aimAngle) * 25,
                    vx: Math.cos(angle) * game.weapon.bulletSpeed, vy: Math.sin(angle) * game.weapon.bulletSpeed,
                    angle, damage: game.weapon.damage, color: game.weapon.color, life: 60
                });
            }
            game.screenShake = bulletsToFire > 1 ? 4 : 2;
            spawnParticles(player.x + Math.cos(aimAngle) * 30, player.y + Math.sin(aimAngle) * 30, game.weapon.color, bulletsToFire > 1 ? 4 : 2);
        }

        function dash() {
            const player = game.player;
            if (player.isKnockedBack || player.isGrounded) return;
            
            // During witch time, can't trigger another witch time
            if (game.witchTime.active) {
                // Normal dash during witch time
                if (player.isDashing) return;
                player.isDashing = true;
                player.dashDuration = 20;
                player.dashAngle = game.hasMoveInput ? game.currentMoveAngle : player.angle;
                player.vx = Math.cos(player.dashAngle) * 18;
                player.vy = Math.sin(player.dashAngle) * 18;
                spawnDust(player.x, player.y, player.dashAngle);
                return;
            }
            
            if (player.isDashing) spawnDust(player.x, player.y, player.dashAngle);
            
            let dashAngle = game.hasMoveInput ? game.currentMoveAngle : player.angle;
            
            const parryTarget = findParryTarget(dashAngle);
            
            if (parryTarget) {
                startParry(parryTarget);
                return;
            }
            
            player.isDashing = true;
            player.dashDuration = 30;
            player.dashCooldown = 35;
            player.dashMeleeUsed = false;
            player.movementPause = 0;
            player.dashAngle = dashAngle;
            
            const currentSpeed = Math.sqrt(player.vx * player.vx + player.vy * player.vy);
            const momentumBonus = Math.min(currentSpeed * 0.5, 8);
            player.dashSpeed = 22 + momentumBonus;
            player.dashMomentum = player.dashSpeed;
            
            player.vx = Math.cos(player.dashAngle) * player.dashSpeed;
            player.vy = Math.sin(player.dashAngle) * player.dashSpeed;
            
            spawnDust(player.x, player.y, player.dashAngle);
            addGhostTrail();
        }

        function buttonJustPressed(buttons, index) {
            return (buttons[index]?.pressed || false) && !(game.prevButtons[index] || false);
        }
        function buttonJustReleased(buttons, index) {
            return !(buttons[index]?.pressed || false) && (game.prevButtons[index] || false);
        }

        function enemyAttackPlayer(enemy) {
            const player = game.player;
            const attackConfig = enemy.type === ENEMY_BOSS ? bossAttack : enemyAttack;
            const dx = player.x - enemy.x;
            const dy = player.y - enemy.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const angleToPlayer = Math.atan2(dy, dx);
            
            if (dist < attackConfig.range + player.radius + 50) {
                damagePlayer(enemy.x, enemy.y, enemy.type === ENEMY_BOSS);
            }
            
            createSlashEffect({
                arc: attackConfig.arc * 0.8,
                duration: 12,
                range: attackConfig.range * 1.2,
                color: enemy.type === ENEMY_BOSS ? '#ffaa00' : '#ff4444'
            }, angleToPlayer, enemy.x, enemy.y, false);
            
            enemy.inParryWindow = false;
            enemy.hasBlinked = false;
            enemy.isCharging = false;
            enemy.chargeTime = 0;
            enemy.attackCooldown = 60;
            enemy.attackPause = attackConfig.attackPauseDuration;
        }

        function update(gamepad) {
            // Update keyboard state at start of frame
            updateKeyboardState();
            
            // Witch time runs in real-time for the timer
            updateWitchTime(1);
            
            // During witch time: enemies slow, player normal
            const inWitchTime = game.witchTime.active && !game.witchTime.circleWipe;
            const enemyTime = inWitchTime ? 0.15 : 1;
            const playerTime = 1; // Player always full speed
            
            if (game.screenShake > 0.5) game.screenShake *= 0.85; else game.screenShake = 0;

            game.shockwaves = game.shockwaves.filter(sw => {
                sw.life -= 1;
                sw.radius += ((sw.maxRadius - 20) / sw.maxLife);
                return sw.life > 0;
            });

            // Update enemy pieces - they move at player speed but suspend longer in witch time
            for (let i = enemyPieces.length - 1; i >= 0; i--) {
                const piece = enemyPieces[i];
                // Add lifetime if not set
                if (piece.lifetime === undefined) piece.lifetime = 180;
                piece.lifetime -= 1;
                
                // During witch time, pieces slow down faster (suspend effect)
                const friction = inWitchTime ? 0.92 : 0.95;
                piece.x += piece.vx;
                piece.y += piece.vy;
                piece.vx *= friction;
                piece.vy *= friction;
                if (piece.hit > 0) piece.hit -= 1;
                
                // Remove: lifetime expired or witch time ended
                if (piece.lifetime <= 0 || (!game.witchTime.active && !game.witchTime.circleWipe)) {
                    spawnParticles(piece.x, piece.y, piece.color, 6, 3);
                    enemyPieces.splice(i, 1);
                }
            }
            
            // Limit max pieces
            while (enemyPieces.length > 30) {
                enemyPieces.shift();
            }
            
            // Limit slashDeaths
            while (game.slashDeaths.length > 20) {
                game.slashDeaths.shift();
            }

            game.slashDeaths = game.slashDeaths.filter(death => {
                death.timer += 1;
                if (death.phase === 'line') {
                    if (death.timer > 20) return false;
                } else if (death.phase === 'flash') {
                    if (death.timer > 8) { death.phase = 'split'; death.timer = 0; }
                } else if (death.phase === 'split') {
                    death.separation += 3;
                    if (death.timer > 15) {
                        death.phase = 'explode'; death.timer = 0;
                        spawnParticles(death.x, death.y, '#ff0000', 10, 6);
                        spawnParticles(death.x, death.y, death.color, 8, 5);
                    }
                } else if (death.phase === 'explode') {
                    if (death.timer > 5) return false;
                }
                return true;
            });

            if (game.hitFreeze > 0) { game.hitFreeze -= 1; return; }

            const player = game.player;

            // Update slot machine
            updateSlotMachine(1);
            
            // Handle slot machine input - R2 (gamepad) or P (keyboard) to select
            if (slotMachine.active && slotMachine.spinning) {
                const r2Value = gamepad ? (gamepad.buttons[7]?.value || 0) : 0;
                if (r2Value > 0.5 || keysJustPressed['KeyP']) {
                    stopSlotMachine();
                }
            }

            // Update player parry indicator - directional wedge pointing at first attackable enemy
            const parryableEnemy = findFirstParryableEnemy();
            if (parryableEnemy && !player.isParrying) {
                const attackConfig = parryableEnemy.type === ENEMY_BOSS ? bossAttack : enemyAttack;
                const chargePercent = parryableEnemy.chargeTime / attackConfig.chargeTime;
                const blinkPercent = attackConfig.blinkTime / attackConfig.chargeTime;
                const angleToEnemy = Math.atan2(parryableEnemy.y - player.y, parryableEnemy.x - player.x);
                const timeSinceBlink = parryableEnemy.chargeTime - attackConfig.blinkTime;
                const isBlinking = parryableEnemy.hasBlinked && timeSinceBlink < attackConfig.blinkDuration;
                
                player.parryIndicator = {
                    chargePercent,
                    blinkPercent,
                    hasBlinked: parryableEnemy.hasBlinked,
                    inParryWindow: parryableEnemy.inParryWindow,
                    angleToEnemy,
                    isBlinking
                };
            } else {
                player.parryIndicator = null;
            }

            game.bossSpawnTimer -= enemyTime;
            if (game.bossSpawnTimer <= 0) {
                spawnBoss();
                game.bossSpawnTimer = game.bossSpawnInterval;
            }

            if (player.hurtTimer > 0) player.hurtTimer -= playerTime;
            if (player.hurtTimer <= 0) player.isHurt = false;
            if (player.cantAttackTimer > 0) player.cantAttackTimer -= playerTime;
            if (player.movementPause > 0) player.movementPause -= playerTime;
            
            if (player.isKnockedBack) {
                player.knockbackTimer -= playerTime;
                player.vx *= 0.95;
                player.vy *= 0.95;
                if (player.knockbackTimer <= 0) {
                    player.isKnockedBack = false;
                    player.isGrounded = true;
                    player.groundedTimer = bossAttack.groundedDuration;
                    player.vx = 0;
                    player.vy = 0;
                    spawnDust(player.x, player.y, 0);
                    game.screenShake = 8;
                }
            }
            
            if (player.isGrounded) {
                player.groundedTimer -= playerTime;
                if (player.groundedTimer <= 0) player.isGrounded = false;
            }

            // Movement input - gamepad or keyboard
            let moveX = 0, moveY = 0;
            if (gamepad) {
                moveX = Math.abs(gamepad.axes[0]) > 0.15 ? gamepad.axes[0] : 0;
                moveY = Math.abs(gamepad.axes[1]) > 0.15 ? gamepad.axes[1] : 0;
            }
            // Keyboard WASD overrides if pressed
            let kbX = 0, kbY = 0;
            if (keys['KeyW'] || keys['ArrowUp']) kbY -= 1;
            if (keys['KeyS'] || keys['ArrowDown']) kbY += 1;
            if (keys['KeyA'] || keys['ArrowLeft']) kbX -= 1;
            if (keys['KeyD'] || keys['ArrowRight']) kbX += 1;
            if (kbX !== 0 || kbY !== 0) {
                // Normalize diagonal
                const len = Math.sqrt(kbX * kbX + kbY * kbY);
                moveX = kbX / len;
                moveY = kbY / len;
            }
            game.hasMoveInput = Math.abs(moveX) > 0.1 || Math.abs(moveY) > 0.1;
            if (game.hasMoveInput) game.currentMoveAngle = Math.atan2(moveY, moveX);

            if (player.dashCooldown > 0 && !player.isDashing) player.dashCooldown -= playerTime;
            if (player.meleeCooldown > 0) player.meleeCooldown -= playerTime;
            if (player.meleeFrame > 0) player.meleeFrame -= playerTime;

            const chargeVisualDelay = 10;
            if (player.isChargingMelee && !player.isParrying) {
                player.meleeChargeTime += playerTime;
                if (player.meleeChargeTime >= player.meleeChargeMax && !player.chargeReady) {
                    player.chargeReady = true;
                    spawnShockwave(player.x, player.y, '#ff00ff', 80);
                    spawnParticles(player.x, player.y, '#ff00ff', 20, 8);
                    game.screenShake = 6;
                }
                if (player.meleeChargeTime > chargeVisualDelay && Math.floor(player.meleeChargeTime) % 4 === 0) {
                    const chargePercent = Math.min(1, (player.meleeChargeTime - chargeVisualDelay) / (player.meleeChargeMax - chargeVisualDelay));
                    const angle = Math.random() * Math.PI * 2;
                    const dist = 30 + Math.random() * 20;
                    game.chargeParticles.push({
                        x: player.x + Math.cos(angle) * dist, y: player.y + Math.sin(angle) * dist,
                        life: 20, maxLife: 20, radius: 2 + chargePercent * 4,
                        color: chargePercent >= 1 ? '#ff00ff' : '#ffaaff'
                    });
                }
            }

            if (player.isKnockedBack || player.isGrounded) {
                // No control
            } else if (player.isDashing) {
                player.dashDuration -= playerTime;
                // More ghost trails during witch time
                if (inWitchTime || Math.floor(player.dashDuration) % 2 === 0) addGhostTrail();
                if (game.hasMoveInput) {
                    let angleDiff = game.currentMoveAngle - player.dashAngle;
                    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                    player.dashAngle += angleDiff * 0.08 * playerTime;
                    const currentSpeed = Math.sqrt(player.vx * player.vx + player.vy * player.vy);
                    player.vx = Math.cos(player.dashAngle) * currentSpeed;
                    player.vy = Math.sin(player.dashAngle) * currentSpeed;
                }
                player.vx *= 0.92;
                player.vy *= 0.92;
                if (player.dashDuration <= 0) {
                    player.isDashing = false;
                    player.postDashWindow = 15; // Post-dash thrust window
                }
            } else if (player.movementPause <= 0) {
                const speedMult = player.isHurt ? player.hurtSlowdown : 1;
                // Collision slowdown
                const collisionMult = player.collisionSlowdown > 0 ? 0.4 : 1;
                const targetVx = moveX * player.speed * speedMult * collisionMult;
                const targetVy = moveY * player.speed * speedMult * collisionMult;
                player.vx += (targetVx - player.vx) * 0.3;
                player.vy += (targetVy - player.vy) * 0.3;
            } else {
                player.vx *= 0.8;
                player.vy *= 0.8;
            }
            
            // Update post-dash window and collision slowdown
            if (player.postDashWindow > 0) player.postDashWindow -= playerTime;
            if (player.collisionSlowdown > 0) player.collisionSlowdown -= playerTime;

            player.x += player.vx * playerTime;
            player.y += player.vy * playerTime;
            player.x = Math.max(player.radius, Math.min(canvas.width - player.radius, player.x));
            player.y = Math.max(player.radius, Math.min(canvas.height - player.radius, player.y));

            // Full autoaim
            updateAutoAim();
            
            // Weapon cycle: L2 (gamepad) or L (keyboard)
            if ((gamepad && buttonJustPressed(gamepad.buttons, 6)) || keysJustPressed['KeyL']) {
                cycleWeapon();
            }

            // Shoot: R2 (gamepad) or P (keyboard)
            const r2Value = gamepad ? (gamepad.buttons[7]?.value || 0) : 0;
            if ((r2Value > 0.5 || keys['KeyP']) && !slotMachine.active) shoot();

            // Melee: R1 (gamepad) or K (keyboard) - only charge attacks, no thrusts
            const r1Pressed = (gamepad && gamepad.buttons[5]?.pressed) || keys['KeyK'];
            const r1JustReleased = (gamepad && buttonJustReleased(gamepad.buttons, 5)) || keysJustReleased['KeyK'];
            
            if (player.cantAttackTimer <= 0 && !player.isParrying && !player.isKnockedBack && !player.isGrounded) {
                if (r1Pressed && !player.isDashing) {
                    startChargingMelee();
                }
            }
            if (r1JustReleased) releaseMelee();
            
            // Dash: L1 (gamepad) or O (keyboard)
            if ((gamepad && buttonJustPressed(gamepad.buttons, 4)) || keysJustPressed['KeyO']) dash();

            // Update gamepad button state
            if (gamepad) {
                game.prevButtons = {};
                gamepad.buttons.forEach((btn, i) => { game.prevButtons[i] = btn.pressed; });
            }

            game.enemies.forEach(enemy => {
                if (enemy.dead) {
                    enemy.respawnTimer -= enemyTime;
                    if (enemy.respawnTimer <= 0) {
                        if (enemy.type === ENEMY_BOSS) {
                            const idx = game.enemies.indexOf(enemy);
                            if (idx > -1) game.enemies.splice(idx, 1);
                            return;
                        }
                        const newEnemy = spawnEnemyFromEdge(enemy.type);
                        Object.assign(enemy, newEnemy);
                        enemy.dead = false;
                    }
                    return;
                }

                if (enemy.health <= 0) return;

                if (enemy.isStunned) {
                    enemy.stunTimer -= enemyTime;
                    if (enemy.stunTimer <= 0) enemy.isStunned = false;
                    if (enemy.hit > 0) enemy.hit -= enemyTime;
                    return;
                }

                if (enemy.attackPause > 0) {
                    enemy.attackPause -= enemyTime;
                    if (enemy.hit > 0) enemy.hit -= enemyTime;
                    return;
                }

                if (enemy.attackCooldown > 0) enemy.attackCooldown -= enemyTime;

                const dx = player.x - enemy.x;
                const dy = player.y - enemy.y;
                const distToPlayer = Math.sqrt(dx * dx + dy * dy);
                const angleToPlayer = Math.atan2(dy, dx);
                
                enemy.isAggro = distToPlayer < enemy.aggroRange;

                if (enemy.isAggro || enemy.isCharging) {
                    let targetAngle = angleToPlayer;
                    let angleDiff = targetAngle - enemy.angle;
                    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                    enemy.angle += angleDiff * 0.1 * enemyTime;
                    
                    if (distToPlayer < enemy.orbitRange) {
                        const orbitAngle = angleToPlayer + Math.PI / 2;
                        enemy.vx = Math.cos(orbitAngle) * enemy.aggroSpeed * 0.5;
                        enemy.vy = Math.sin(orbitAngle) * enemy.aggroSpeed * 0.5;
                    } else if (distToPlayer < enemy.aggroRange) {
                        enemy.vx = Math.cos(angleToPlayer) * enemy.aggroSpeed;
                        enemy.vy = Math.sin(angleToPlayer) * enemy.aggroSpeed;
                    } else {
                        enemy.vx *= 0.95;
                        enemy.vy *= 0.95;
                    }
                    
                    if (!enemy.isCharging && enemy.attackCooldown <= 0 && distToPlayer < enemy.chargeRange) {
                        enemy.isCharging = true;
                        enemy.chargeTime = 0;
                        enemy.inParryWindow = false;
                        enemy.hasBlinked = false;
                    }
                    
                    if (enemy.isCharging) {
                        enemy.chargeTime += enemyTime;
                        const attackConfig = enemy.type === ENEMY_BOSS ? bossAttack : enemyAttack;
                        
                        if (enemy.chargeTime >= attackConfig.blinkTime && !enemy.hasBlinked) {
                            enemy.hasBlinked = true;
                            enemy.inParryWindow = true;
                        }
                        
                        if (enemy.chargeTime >= attackConfig.chargeTime) {
                            enemyAttackPlayer(enemy);
                        }
                    }
                } else {
                    enemy.isCharging = false;
                    enemy.chargeTime = 0;
                    enemy.inParryWindow = false;
                    enemy.hasBlinked = false;
                    
                    enemy.moveTimer -= enemyTime;
                    if (enemy.moveTimer <= 0) {
                        const newAngle = Math.random() * Math.PI * 2;
                        enemy.vx = Math.cos(newAngle) * enemy.baseSpeed;
                        enemy.vy = Math.sin(newAngle) * enemy.baseSpeed;
                        enemy.angle = newAngle;
                        enemy.moveTimer = 90 + Math.random() * 150;
                    }
                }

                enemy.x += enemy.vx * enemyTime;
                enemy.y += enemy.vy * enemyTime;

                const boundSize = enemy.size / 2;
                if (enemy.x < boundSize || enemy.x > canvas.width - boundSize) {
                    enemy.vx *= -1;
                    enemy.x = Math.max(boundSize, Math.min(canvas.width - boundSize, enemy.x));
                }
                if (enemy.y < boundSize || enemy.y > canvas.height - boundSize) {
                    enemy.vy *= -1;
                    enemy.y = Math.max(boundSize, Math.min(canvas.height - boundSize, enemy.y));
                }

                if (enemy.hit > 0) enemy.hit -= enemyTime;
            });
            
            // Enemy-enemy collision
            for (let i = 0; i < game.enemies.length; i++) {
                const e1 = game.enemies[i];
                if (e1.dead || e1.health <= 0) continue;
                
                for (let j = i + 1; j < game.enemies.length; j++) {
                    const e2 = game.enemies[j];
                    if (e2.dead || e2.health <= 0) continue;
                    
                    const dx = e2.x - e1.x;
                    const dy = e2.y - e1.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const minDist = (e1.size + e2.size) / 2;
                    
                    if (dist < minDist && dist > 0) {
                        const overlap = minDist - dist;
                        const nx = dx / dist;
                        const ny = dy / dist;
                        e1.x -= nx * overlap * 0.5;
                        e1.y -= ny * overlap * 0.5;
                        e2.x += nx * overlap * 0.5;
                        e2.y += ny * overlap * 0.5;
                        e1.vx -= nx * 0.3;
                        e1.vy -= ny * 0.3;
                        e2.vx += nx * 0.3;
                        e2.vy += ny * 0.3;
                    }
                }
                
                // Enemy-player collision
                if (!player.isDashing && !player.isKnockedBack) {
                    const dx = player.x - e1.x;
                    const dy = player.y - e1.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const minDist = player.radius + e1.size / 2;
                    
                    if (dist < minDist && dist > 0) {
                        const overlap = minDist - dist;
                        const nx = dx / dist;
                        const ny = dy / dist;
                        player.x += nx * overlap;
                        player.y += ny * overlap;
                        player.collisionSlowdown = 8;
                    }
                }
            }

            game.bullets = game.bullets.filter(bullet => {
                bullet.x += bullet.vx;
                bullet.y += bullet.vy;
                bullet.life -= 1;
                for (let enemy of game.enemies) {
                    if (enemy.health <= 0 || enemy.dead) continue;
                    const dx = bullet.x - enemy.x;
                    const dy = bullet.y - enemy.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < enemy.size / 2 + 4) {
                        enemy.health -= bullet.damage;
                        enemy.hit = 10;
                        stunEnemy(enemy);
                        game.screenShake = 4;
                        enemy.x += Math.cos(bullet.angle) * 5;
                        enemy.y += Math.sin(bullet.angle) * 5;
                        spawnParticles(bullet.x, bullet.y, enemy.color, 8);
                        if (enemy.health <= 0) killEnemy(enemy, game.player.x, game.player.y, false);
                        return false;
                    }
                }
                if (bullet.x < 0 || bullet.x > canvas.width || bullet.y < 0 || bullet.y > canvas.height) return false;
                return bullet.life > 0;
            });

            game.particles = game.particles.filter(p => {
                p.x += p.vx; p.y += p.vy;
                p.vx *= 0.95; p.vy *= 0.95; p.life -= 1;
                return p.life > 0;
            });
            // Hard limit particles
            while (game.particles.length > 150) game.particles.shift();
            
            game.dustParticles = game.dustParticles.filter(p => {
                p.x += p.vx; p.y += p.vy;
                p.vx *= 0.9; p.vy *= 0.9; p.life -= 1;
                return p.life > 0;
            });
            while (game.dustParticles.length > 50) game.dustParticles.shift();
            
            game.chargeParticles = game.chargeParticles.filter(p => {
                const dx = player.x - p.x; const dy = player.y - p.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > 2) { p.x += (dx / dist) * 4; p.y += (dy / dist) * 4; }
                p.life -= 1;
                return p.life > 0;
            });
            game.ghostTrails = game.ghostTrails.filter(g => { g.life -= 1; return g.life > 0; });
            game.slashEffects = game.slashEffects.filter(s => {
                if (s.trackPlayer) { s.x = player.x; s.y = player.y; }
                s.life -= 1;
                return s.life > 0;
            });
        }

        function drawCircle(x, y, radius, color) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawDiamond(x, y, size, angle, color) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle + Math.PI / 4);
            ctx.fillStyle = color;
            ctx.fillRect(-size/2, -size/2, size, size);
            ctx.restore();
        }

        function drawPentagon(x, y, size, angle, color) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle - Math.PI / 2);
            ctx.fillStyle = color;
            ctx.beginPath();
            for (let i = 0; i < 5; i++) {
                const a = (i / 5) * Math.PI * 2;
                const px = Math.cos(a) * size * 0.55;
                const py = Math.sin(a) * size * 0.55;
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }

        function drawHalfShape(x, y, size, type, cutAngle, side, color) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(cutAngle);
            ctx.beginPath();
            ctx.rect(-size, side > 0 ? 0 : -size, size * 2, size);
            ctx.clip();
            ctx.rotate(-cutAngle);
            ctx.fillStyle = color;
            
            if (type === ENEMY_NORMAL) {
                ctx.beginPath();
                ctx.arc(0, 0, size / 2, 0, Math.PI * 2);
                ctx.fill();
            } else if (type === ENEMY_BIG) {
                ctx.save();
                ctx.rotate(Math.PI / 4);
                ctx.fillRect(-size/2, -size/2, size, size);
                ctx.restore();
            } else if (type === ENEMY_BOSS) {
                ctx.beginPath();
                for (let i = 0; i < 5; i++) {
                    const a = (i / 5) * Math.PI * 2 - Math.PI / 2;
                    const px = Math.cos(a) * size * 0.55;
                    const py = Math.sin(a) * size * 0.55;
                    if (i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.closePath();
                ctx.fill();
            }
            ctx.restore();
        }

        function drawPlayer(x, y, radius, angle, color, isCharging, chargePercent, isHurt, isGrounded) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle);
            if (isCharging && chargePercent > 0) {
                ctx.globalAlpha = 0.3 + chargePercent * 0.4;
                ctx.fillStyle = chargePercent >= 1 ? '#ff00ff' : '#ffaaff';
                ctx.beginPath();
                ctx.arc(0, 0, radius * (1.5 + chargePercent * 0.5), 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
            ctx.fillStyle = isGrounded ? '#888888' : (isHurt ? '#ff6666' : color);
            ctx.beginPath();
            ctx.moveTo(radius * 1.3, 0);
            ctx.arc(0, 0, radius, -Math.PI * 0.25, Math.PI * 0.25, true);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }

        function drawGhostShape(x, y, radius, angle, alpha) {
            ctx.save();
            ctx.globalAlpha = alpha;
            ctx.translate(x, y);
            ctx.rotate(angle);
            ctx.fillStyle = '#4ecca3';
            ctx.beginPath();
            ctx.moveTo(radius * 1.3, 0);
            ctx.arc(0, 0, radius, -Math.PI * 0.25, Math.PI * 0.25, true);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
            ctx.globalAlpha = 1;
        }

        function render() {
            const player = game.player;
            
            ctx.save();
            
            if (game.screenShake > 0.5) {
                ctx.translate((Math.random() - 0.5) * game.screenShake * 2, (Math.random() - 0.5) * game.screenShake * 2);
            }

            ctx.fillStyle = '#16213e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.strokeStyle = '#1a2744';
            ctx.lineWidth = 1;
            for (let x = 0; x < canvas.width; x += 50) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke(); }
            for (let y = 0; y < canvas.height; y += 50) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke(); }

            game.shockwaves.forEach(sw => {
                ctx.strokeStyle = sw.color;
                ctx.lineWidth = 2;
                ctx.globalAlpha = (sw.life / sw.maxLife) * 0.8;
                ctx.beginPath();
                ctx.arc(sw.x, sw.y, sw.radius, 0, Math.PI * 2);
                ctx.stroke();
            });
            ctx.globalAlpha = 1;

            game.dustParticles.forEach(p => {
                ctx.globalAlpha = (p.life / p.maxLife) * 0.5;
                ctx.fillStyle = '#8b7355';
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.radius * (p.life / p.maxLife), 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;

            game.chargeParticles.forEach(p => {
                ctx.globalAlpha = p.life / p.maxLife;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;

            game.ghostTrails.forEach(ghost => {
                drawGhostShape(ghost.x, ghost.y, ghost.radius, ghost.angle, (ghost.life / ghost.maxLife) * 0.5);
            });

            game.particles.forEach(p => {
                ctx.globalAlpha = p.life / p.maxLife;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.radius * (p.life / p.maxLife), 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;

            game.slashEffects.forEach(slash => {
                const progress = 1 - (slash.life / slash.maxLife);
                ctx.save();
                ctx.translate(slash.x, slash.y);
                ctx.rotate(slash.angle);
                ctx.globalAlpha = (slash.life / slash.maxLife) * 0.9;
                if (slash.type === 'arc') {
                    // Thicker line for charged attacks
                    const baseWidth = slash.isCharged ? 6 : 4;
                    ctx.strokeStyle = slash.color;
                    ctx.lineWidth = baseWidth + (1 - progress) * baseWidth;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.arc(0, 0, slash.range * (0.5 + progress * 0.5), -slash.arc / 2 + progress * 0.5, slash.arc / 2 - progress * 0.5);
                    ctx.stroke();
                } else if (slash.type === 'thrust') {
                    const len = slash.length * (0.5 + progress * 0.5);
                    const w = slash.width * (1 - progress * 0.3);
                    const offset = slash.offset || 0;
                    const tipLen = 25;
                    const backTipLen = 12; // Pointed back (shorter than front)
                    
                    // Trail effect (draw multiple times with increasing alpha)
                    for (let t = 0; t < 3; t++) {
                        const trailOffset = t * 8;
                        const trailAlpha = (1 - t * 0.3) * (slash.life / slash.maxLife);
                        ctx.globalAlpha = trailAlpha * 0.7;
                        ctx.fillStyle = slash.color;
                        ctx.beginPath();
                        // Front point
                        ctx.moveTo(offset + len + tipLen - trailOffset, 0);
                        // Top edge
                        ctx.lineTo(offset + len - trailOffset, -w/4);
                        ctx.lineTo(offset - trailOffset, -w/2);
                        // Back point (pointed, not flat)
                        ctx.lineTo(offset - backTipLen - trailOffset, 0);
                        // Bottom edge
                        ctx.lineTo(offset - trailOffset, w/2);
                        ctx.lineTo(offset + len - trailOffset, w/4);
                        ctx.closePath();
                        ctx.fill();
                    }
                    ctx.globalAlpha = (slash.life / slash.maxLife) * 0.9;
                }
                ctx.restore();
            });
            ctx.globalAlpha = 1;

            game.slashDeaths.forEach(death => {
                if (death.phase === 'line') {
                    // Longer slash line with fade at tips
                    const lineLen = death.size * 1.8;
                    const alpha = 1 - (death.timer / 20);
                    const x1 = death.x + Math.cos(death.slashAngle) * lineLen;
                    const y1 = death.y + Math.sin(death.slashAngle) * lineLen;
                    const x2 = death.x - Math.cos(death.slashAngle) * lineLen;
                    const y2 = death.y - Math.sin(death.slashAngle) * lineLen;
                    
                    const gradient = ctx.createLinearGradient(x1, y1, x2, y2);
                    gradient.addColorStop(0, `rgba(255,255,255,0)`);
                    gradient.addColorStop(0.2, `rgba(255,255,255,${alpha})`);
                    gradient.addColorStop(0.8, `rgba(255,255,255,${alpha})`);
                    gradient.addColorStop(1, `rgba(255,255,255,0)`);
                    
                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = 3;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                } else if (death.phase === 'flash') {
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(death.x, death.y, death.size * 0.7, 0, Math.PI * 2);
                    ctx.fill();
                } else if (death.phase === 'split') {
                    const perpAngle = death.slashAngle + Math.PI / 2;
                    const sep = death.separation;
                    drawHalfShape(death.x + Math.cos(perpAngle) * sep, death.y + Math.sin(perpAngle) * sep, 
                        death.size, death.type, death.slashAngle, 1, death.color);
                    drawHalfShape(death.x - Math.cos(perpAngle) * sep, death.y - Math.sin(perpAngle) * sep, 
                        death.size, death.type, death.slashAngle, -1, death.color);
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.globalAlpha = 0.8;
                    ctx.beginPath();
                    ctx.moveTo(death.x + Math.cos(death.slashAngle) * death.size, death.y + Math.sin(death.slashAngle) * death.size);
                    ctx.lineTo(death.x - Math.cos(death.slashAngle) * death.size, death.y - Math.sin(death.slashAngle) * death.size);
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                }
            });

            // Enemy pieces (during witch time)
            enemyPieces.forEach(piece => {
                if (piece.health <= 0) return;
                const drawColor = piece.hit > 0 ? '#ffffff' : piece.color;
                
                // Draw as half shape based on cut
                if (piece.cutAngle !== undefined) {
                    drawHalfShape(piece.x, piece.y, piece.size, piece.type, piece.cutAngle, piece.side, drawColor);
                } else {
                    drawCircle(piece.x, piece.y, piece.size / 2, drawColor);
                }
            });

            // Enemies - draw all charging rings (not affected by parry state)
            game.enemies.forEach(enemy => {
                if (enemy.health <= 0 || enemy.dead) return;
                
                if (enemy.isCharging) {
                    const attackConfig = enemy.type === ENEMY_BOSS ? bossAttack : enemyAttack;
                    const chargePercent = enemy.chargeTime / attackConfig.chargeTime;
                    const maxBorderDist = 25;
                    const borderDist = maxBorderDist - (chargePercent * maxBorderDist);
                    
                    // Longer blink duration check
                    const timeSinceBlink = enemy.chargeTime - attackConfig.blinkTime;
                    const isBlinking = enemy.hasBlinked && timeSinceBlink < attackConfig.blinkDuration;
                    
                    let borderColor;
                    if (!enemy.hasBlinked) {
                        borderColor = '#ffcc00';
                    } else if (isBlinking) {
                        borderColor = '#ffffff';
                    } else {
                        borderColor = '#ff3333';
                    }
                    
                    ctx.strokeStyle = borderColor;
                    ctx.lineWidth = 2;
                    ctx.globalAlpha = 0.6 + chargePercent * 0.3;
                    
                    const size = enemy.size / 2 + borderDist;
                    ctx.beginPath();
                    ctx.arc(enemy.x, enemy.y, size, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                }
                
                if (enemy.isStunned) {
                    for (let i = 0; i < 3; i++) {
                        const starAngle = (Date.now() / 200 + i * Math.PI * 2 / 3) % (Math.PI * 2);
                        const starX = enemy.x + Math.cos(starAngle) * (enemy.size / 2 + 10);
                        const starY = enemy.y - enemy.size / 2 - 5 + Math.sin(starAngle * 2) * 3;
                        ctx.fillStyle = '#ffff00';
                        ctx.beginPath();
                        ctx.arc(starX, starY, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                const drawColor = enemy.hit > 0 ? '#ffffff' : enemy.color;
                
                if (enemy.type === ENEMY_NORMAL) {
                    drawCircle(enemy.x, enemy.y, enemy.size / 2, drawColor);
                } else if (enemy.type === ENEMY_BIG) {
                    drawDiamond(enemy.x, enemy.y, enemy.size, enemy.angle, drawColor);
                } else if (enemy.type === ENEMY_BOSS) {
                    drawPentagon(enemy.x, enemy.y, enemy.size, enemy.angle, drawColor);
                }
            });

            game.bullets.forEach(bullet => {
                ctx.fillStyle = bullet.color;
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = bullet.color;
                ctx.globalAlpha = 0.5;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(bullet.x, bullet.y);
                ctx.lineTo(bullet.x - bullet.vx * 2, bullet.y - bullet.vy * 2);
                ctx.stroke();
                ctx.globalAlpha = 1;
            });

            // Player
            if (player.isDashing) {
                ctx.globalAlpha = 0.4;
                ctx.fillStyle = player.isParrying ? (game.parryCircle?.color || '#aa66ff') : '#88ffcc';
                ctx.beginPath();
                ctx.arc(player.x, player.y, player.radius * 1.8, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }

            const chargeVisualDelay = 10;
            const showChargeVisual = player.isChargingMelee && player.meleeChargeTime > chargeVisualDelay;
            const visualChargePercent = showChargeVisual ? Math.min(1, (player.meleeChargeTime - chargeVisualDelay) / (player.meleeChargeMax - chargeVisualDelay)) : 0;
            const hurtFlash = player.isHurt && Math.floor(player.hurtTimer / 4) % 2 === 0;
            drawPlayer(player.x, player.y, player.radius, player.angle, player.color, showChargeVisual, visualChargePercent, hurtFlash, player.isGrounded);

            // Player parry indicator removed - using enemy rings only

            ctx.restore();

            // Witch time color filter
            if (game.witchTime.active && game.violetFilter > 0.01) {
                ctx.fillStyle = `rgba(136, 0, 255, ${game.violetFilter * 0.3})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            
            // Witch time circle wipe (closing inward)
            if (game.witchTime.circleWipe) {
                const wipe = game.witchTime.circleWipe;
                ctx.fillStyle = '#000000';
                ctx.beginPath();
                // Draw a rectangle with a circular hole
                ctx.rect(0, 0, canvas.width, canvas.height);
                ctx.arc(wipe.centerX, wipe.centerY, Math.max(0, wipe.radius), 0, Math.PI * 2, true);
                ctx.fill();
            }
            
            // Witch time timer indicator (around player)
            if (game.witchTime.active && !game.witchTime.circleWipe) {
                const wt = game.witchTime;
                const progress = wt.timer / wt.maxTime;
                const arcRadius = player.radius + 25;
                
                // Background arc
                ctx.strokeStyle = '#333333';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(player.x, player.y, arcRadius, 0, Math.PI * 2);
                ctx.stroke();
                
                // Progress arc
                ctx.strokeStyle = progress < 0.25 ? '#ff4444' : '#8800ff';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(player.x, player.y, arcRadius, -Math.PI / 2, -Math.PI / 2 + progress * Math.PI * 2);
                ctx.stroke();
            }
            
            // UI Layer (not affected by screen shake)
            
            // XP Bar
            const barWidth = 300;
            const barHeight = 12;
            const barX = (canvas.width - barWidth) / 2;
            const barY = canvas.height - 40;
            
            // Bar background
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(barX - 2, barY - 2, barWidth + 4, barHeight + 4);
            ctx.fillStyle = '#2a2a4e';
            ctx.fillRect(barX, barY, barWidth, barHeight);
            
            // XP fill
            const xpPercent = xpSystem.xp / xpSystem.xpToNext;
            ctx.fillStyle = '#4ecca3';
            ctx.fillRect(barX, barY, barWidth * xpPercent, barHeight);
            
            // Level text
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 14px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(`LVL ${xpSystem.level}`, canvas.width / 2, barY - 8);
            
            // Power-up icons above XP bar
            const iconStartX = barX;
            const iconY = barY - 35;
            let iconOffset = 0;
            
            Object.keys(powerUps).forEach(key => {
                if (powerUps[key] > 0) {
                    const cfg = powerUpConfig[key];
                    ctx.font = '16px sans-serif';
                    ctx.fillStyle = cfg.color;
                    ctx.textAlign = 'left';
                    ctx.fillText(cfg.icon, iconStartX + iconOffset, iconY);
                    ctx.font = 'bold 12px sans-serif';
                    ctx.fillStyle = '#ffffff';
                    ctx.fillText(`${powerUps[key]}`, iconStartX + iconOffset + 22, iconY);
                    iconOffset += 45;
                }
            });
            
            // Weapon display (right side of XP bar)
            const weaponName = game.weapon.name || 'SMG';
            ctx.font = 'bold 14px sans-serif';
            ctx.textAlign = 'right';
            ctx.fillStyle = game.weapon.color;
            ctx.fillText(weaponName, barX + barWidth, iconY);
            
            // Slot Machine UI - floating next to player (in world space, before ctx.restore)
            if (slotMachine.active) {
                const currentOption = slotMachine.options[slotMachine.currentIndex];
                const cfg = powerUpConfig[currentOption];
                
                // Position floating to the right of player
                const floatX = player.x + 50;
                const floatY = player.y - 30;
                
                // Box size
                const boxSize = 40;
                
                if (slotMachine.spinning) {
                    // Spinning state - show cycling icons with colored border
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.beginPath();
                    ctx.arc(floatX, floatY, boxSize / 2 + 5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.strokeStyle = cfg.color;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(floatX, floatY, boxSize / 2 + 5, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Icon
                    ctx.font = '24px sans-serif';
                    ctx.fillStyle = '#ffffff';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(cfg.icon, floatX, floatY);
                    
                    // Small R2 hint below
                    ctx.font = '10px sans-serif';
                    ctx.fillStyle = '#888888';
                    ctx.fillText('R2', floatX, floatY + boxSize / 2 + 12);
                } else {
                    // Selected state - white blink effect
                    const blinkPhase = Math.floor(slotMachine.displayTimer / 8) % 2;
                    const isBlinking = slotMachine.displayTimer > 120; // Blink for first ~0.5s
                    
                    if (isBlinking && blinkPhase === 0) {
                        // White flash
                        ctx.fillStyle = '#ffffff';
                        ctx.beginPath();
                        ctx.arc(floatX, floatY, boxSize / 2 + 8, 0, Math.PI * 2);
                        ctx.fill();
                    } else {
                        // Normal display with color
                        ctx.fillStyle = cfg.color;
                        ctx.globalAlpha = 0.4;
                        ctx.beginPath();
                        ctx.arc(floatX, floatY, boxSize / 2 + 5, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.globalAlpha = 1;
                        
                        ctx.strokeStyle = cfg.color;
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(floatX, floatY, boxSize / 2 + 5, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    
                    // Icon (always visible)
                    ctx.font = '24px sans-serif';
                    ctx.fillStyle = '#ffffff';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(cfg.icon, floatX, floatY);
                    
                    // +1 indicator
                    ctx.font = 'bold 14px sans-serif';
                    ctx.fillStyle = cfg.color;
                    ctx.fillText('+1', floatX, floatY + boxSize / 2 + 12);
                }
                
                ctx.textBaseline = 'alphabetic'; // Reset
            }
            
        }

        function gameLoop() {
            const gamepads = navigator.getGamepads();
            let activeGamepad = null;
            for (const gp of gamepads) { if (gp && gp.connected) { activeGamepad = gp; break; } }
            update(activeGamepad); // Always update, gamepad can be null
            render();
            requestAnimationFrame(gameLoop);
        }

        window.addEventListener('gamepadconnected', (e) => console.log('Gamepad connected:', e.gamepad.id));
        window.addEventListener('gamepaddisconnected', (e) => console.log('Gamepad disconnected'));

        resizeCanvas();
        game.player.x = canvas.width / 2;
        game.player.y = canvas.height / 2;
        initEnemies();
        gameLoop();
    </script>
</body>
</html>
